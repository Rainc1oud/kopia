@startuml
namespace acl {
    class AccessLevel << (S,Aquamarine) >> {
        + String() string
        + MarshalJSON() ([]byte, error)
        + UnmarshalJSON(b []byte) error

    }
    class Entry << (S,Aquamarine) >> {
        + ManifestID manifest.ID
        + User string
        + Target TargetRule
        + Access AccessLevel

        + Validate() error

    }
    class TargetRule << (S,Aquamarine) >> {
        + String() string

    }
    class acl.AccessLevel << (T, #FF7700) >>  {
    }
    class acl.TargetRule << (T, #FF7700) >>  {
    }
    class acl.valueValidatorFunc << (T, #FF7700) >>  {
    }
}


namespace apiclient {
    class HTTPStatusError << (S,Aquamarine) >> {
        + HTTPStatusCode int
        + ErrorMessage string

        + Error() string

    }
    class KopiaAPIClient << (S,Aquamarine) >> {
        + BaseURL string
        + HTTPClient *http.Client
        + CSRFToken string

        + Get(ctx context.Context, urlSuffix string, onNotFound error, respPayload <font color=blue>interface</font>{}) error
        + Post(ctx context.Context, urlSuffix string, reqPayload <font color=blue>interface</font>{}, respPayload <font color=blue>interface</font>{}) error
        + Put(ctx context.Context, urlSuffix string, reqPayload <font color=blue>interface</font>{}, respPayload <font color=blue>interface</font>{}) error
        + Delete(ctx context.Context, urlSuffix string, onNotFound error, reqPayload <font color=blue>interface</font>{}, respPayload <font color=blue>interface</font>{}) error
        + FetchCSRFTokenForTesting(ctx context.Context) error

    }
    class Options << (S,Aquamarine) >> {
        + BaseURL string
        + Username string
        + Password string
        + TrustedServerCertificateFingerprint string
        + LogRequests bool

    }
    class basicAuthTransport << (S,Aquamarine) >> {
        + RoundTrip(req *http.Request) (*http.Response, error)

    }
    class loggingTransport << (S,Aquamarine) >> {
        + RoundTrip(req *http.Request) (*http.Response, error)

    }
}


namespace auth {
    interface Authenticator  {
        + IsValid(ctx context.Context, rep repo.Repository, username string, password string) bool
        + Refresh(ctx context.Context) error

    }
    interface AuthorizationInfo  {
        + ContentAccessLevel() AccessLevel
        + ManifestAccessLevel(labels <font color=blue>map</font>[string]string) AccessLevel

    }
    interface Authorizer  {
        + Authorize(ctx context.Context, rep repo.Repository, username string) AuthorizationInfo
        + Refresh(ctx context.Context) error

    }
    class aclCache << (S,Aquamarine) >> {
        + Authorize(ctx context.Context, rep repo.Repository, usernameAtHostname string) AuthorizationInfo
        + Refresh(ctx context.Context) error

    }
    class aclEntriesAuthorizer << (S,Aquamarine) >> {
        + ContentAccessLevel() AccessLevel
        + ManifestAccessLevel(labels <font color=blue>map</font>[string]string) AccessLevel

    }
    class auth.AccessLevel << (T, #FF7700) >>  {
    }
    class auth.combinedAuthenticator << (T, #FF7700) >>  {
    }
    class combinedAuthenticator << (S,Aquamarine) >> {
        + IsValid(ctx context.Context, rep repo.Repository, username string, password string) bool
        + Refresh(ctx context.Context) error

    }
    class htpasswdAuthenticator << (S,Aquamarine) >> {
        + IsValid(ctx context.Context, rep repo.Repository, username string, password string) bool
        + Refresh(ctx context.Context) error

    }
    class legacyAuthorizationInfo << (S,Aquamarine) >> {
        + ContentAccessLevel() AccessLevel
        + ManifestAccessLevel(labels <font color=blue>map</font>[string]string) AccessLevel

    }
    class legacyAuthorizer << (S,Aquamarine) >> {
        + Authorize(ctx context.Context, rep repo.Repository, username string) AuthorizationInfo
        + Refresh(ctx context.Context) error

    }
    class noAccessAuthorizationInfo << (S,Aquamarine) >> {
        + ContentAccessLevel() AccessLevel
        + ManifestAccessLevel(labels <font color=blue>map</font>[string]string) AccessLevel

    }
    class repositoryUserAuthenticator << (S,Aquamarine) >> {
        + IsValid(ctx context.Context, rep repo.Repository, username string, password string) bool
        + Refresh(ctx context.Context) error

    }
    class singleUserAuthenticator << (S,Aquamarine) >> {
        + IsValid(ctx context.Context, rep repo.Repository, username string, password string) bool
        + Refresh(ctx context.Context) error

    }
    class "acl.AccessLevel" as aclAccessLevel {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
}

"auth.Authorizer" <|-- "auth.aclCache"
"auth.AuthorizationInfo" <|-- "auth.aclEntriesAuthorizer"
"auth.Authenticator" <|-- "auth.combinedAuthenticator"
"auth.Authenticator" <|-- "auth.htpasswdAuthenticator"
"auth.AuthorizationInfo" <|-- "auth.legacyAuthorizationInfo"
"auth.Authorizer" <|-- "auth.legacyAuthorizer"
"auth.AuthorizationInfo" <|-- "auth.noAccessAuthorizationInfo"
"auth.Authenticator" <|-- "auth.repositoryUserAuthenticator"
"auth.Authenticator" <|-- "auth.singleUserAuthenticator"

namespace azure {
    class Options << (S,Aquamarine) >> {
        + Container string
        + Prefix string
        + StorageAccount string
        + StorageKey string
        + SASToken string
        + StorageDomain string

    }
    class azStorage << (S,Aquamarine) >> {
        + GetCapacity(ctx context.Context) (blob.Capacity, error)
        + GetBlob(ctx context.Context, b blob.ID, offset int64, length int64, output blob.OutputBuffer) error
        + GetMetadata(ctx context.Context, b blob.ID) (blob.Metadata, error)
        + PutBlob(ctx context.Context, b blob.ID, data blob.Bytes, opts blob.PutOptions) error
        + DeleteBlob(ctx context.Context, b blob.ID) error
        + ListBlobs(ctx context.Context, prefix blob.ID, callback <font color=blue>func</font>(blob.Metadata) error) error
        + ConnectionInfo() blob.ConnectionInfo
        + DisplayName() string
        + Close(ctx context.Context) error
        + FlushCaches(ctx context.Context) error

    }
}
"throttling.Limits" *-- "azure.Options"
"azure.Options" *-- "azure.azStorage"

"blob.Storage" <|-- "azure.azStorage"
"blob.Volume" <|-- "azure.azStorage"

namespace b2 {
    class Options << (S,Aquamarine) >> {
        + BucketName string
        + Prefix string
        + KeyID string
        + Key string

    }
    class b2Storage << (S,Aquamarine) >> {
        + GetCapacity(ctx context.Context) (blob.Capacity, error)
        + GetBlob(ctx context.Context, id blob.ID, offset int64, length int64, output blob.OutputBuffer) error
        + GetMetadata(ctx context.Context, id blob.ID) (blob.Metadata, error)
        + PutBlob(ctx context.Context, id blob.ID, data blob.Bytes, opts blob.PutOptions) error
        + DeleteBlob(ctx context.Context, id blob.ID) error
        + ListBlobs(ctx context.Context, prefix blob.ID, callback <font color=blue>func</font>(blob.Metadata) error) error
        + ConnectionInfo() blob.ConnectionInfo
        + DisplayName() string
        + Close(ctx context.Context) error
        + FlushCaches(ctx context.Context) error
        + String() string

    }
}
"throttling.Limits" *-- "b2.Options"
"b2.Options" *-- "b2.b2Storage"

"blob.Storage" <|-- "b2.b2Storage"
"blob.Volume" <|-- "b2.b2Storage"

namespace beforeop {
    class beforeOp << (S,Aquamarine) >> {
        + GetBlob(ctx context.Context, id blob.ID, offset int64, length int64, output blob.OutputBuffer) error
        + GetMetadata(ctx context.Context, id blob.ID) (blob.Metadata, error)
        + PutBlob(ctx context.Context, id blob.ID, data blob.Bytes, opts blob.PutOptions) error
        + DeleteBlob(ctx context.Context, id blob.ID) error

    }
    class beforeop.callback << (T, #FF7700) >>  {
    }
    class beforeop.onGetBlobCallback << (T, #FF7700) >>  {
    }
    class beforeop.onPutBlobCallback << (T, #FF7700) >>  {
    }
    class "<font color=blue>func</font>(context.Context, blob.ID, *blob.PutOptions) error" as fontcolorbluefuncfontcontextContextblobIDblobPutOptionserror {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "<font color=blue>func</font>(context.Context, blob.ID) error" as fontcolorbluefuncfontcontextContextblobIDerror {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "<font color=blue>func</font>(context.Context) error" as fontcolorbluefuncfontcontextContexterror {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
}
"blob.Storage" *-- "beforeop.beforeOp"


namespace bigmap {
    class Map << (S,Aquamarine) >> {
        + PutIfAbsent(ctx context.Context, key []byte, value []byte) bool
        + Get(ctx context.Context, output []byte, key []byte) ([]byte, bool, error)
        + Contains(key []byte) bool
        + Close(ctx context.Context) 

    }
    class Options << (S,Aquamarine) >> {
        + LoadFactorPercentage int
        + NumMemorySegments int
        + MemorySegmentSize int64
        + FileSegmentSize int
        + InitialSizeLogarithm int

    }
    class Set << (S,Aquamarine) >> {
        + Put(ctx context.Context, key []byte) bool
        + Contains(key []byte) bool
        + Close(ctx context.Context) 

    }
    class entry << (S,Aquamarine) >> {
    }
    class internalMap << (S,Aquamarine) >> {
        + Contains(key []byte) bool
        + Get(buf []byte, key []byte) ([]byte, bool)
        + PutIfAbsent(ctx context.Context, key []byte, value []byte) bool
        + Close(ctx context.Context) 

    }
}


namespace blob {
    interface Bytes  {
        + Length() int
        + Reader() io.ReadSeekCloser

    }
    class Capacity << (S,Aquamarine) >> {
        + SizeB uint64
        + FreeB uint64

    }
    class ConnectionInfo << (S,Aquamarine) >> {
        + Type string
        + Config <font color=blue>interface</font>{}

        + UnmarshalJSON(b []byte) error
        + MarshalJSON() ([]byte, error)

    }
    class Metadata << (S,Aquamarine) >> {
        + BlobID ID
        + Length int64
        + Timestamp time.Time

        + String() string

    }
    interface OutputBuffer  {
        + Reset() 
        + Length() int

    }
    class PutOptions << (S,Aquamarine) >> {
        + RetentionMode RetentionMode
        + RetentionPeriod time.Duration
        + DoNotRecreate bool
        + SetModTime time.Time
        + GetModTime *time.Time

        + HasRetentionOptions() bool

    }
    interface Reader  {
        + GetBlob(ctx context.Context, blobID ID, offset int64, length int64, output OutputBuffer) error
        + GetMetadata(ctx context.Context, blobID ID) (Metadata, error)
        + ListBlobs(ctx context.Context, blobIDPrefix ID, cb <font color=blue>func</font>(Metadata) error) error
        + ConnectionInfo() ConnectionInfo
        + DisplayName() string

    }
    class RetentionMode << (S,Aquamarine) >> {
        + String() string
        + IsValid() bool

    }
    interface Storage  {
        + PutBlob(ctx context.Context, blobID ID, data Bytes, opts PutOptions) error
        + DeleteBlob(ctx context.Context, blobID ID) error
        + Close(ctx context.Context) error
        + FlushCaches(ctx context.Context) error

    }
    interface Volume  {
        + GetCapacity(ctx context.Context) (Capacity, error)

    }
    class blob.ID << (T, #FF7700) >>  {
    }
    class blob.RetentionMode << (T, #FF7700) >>  {
    }
    class storageFactory << (S,Aquamarine) >> {
    }
}
"blob.Reader" *-- "blob.Storage"
"blob.Volume" *-- "blob.Storage"


namespace blobcrypto {
    interface Crypter  {
        + HashFunc() hashing.HashFunc
        + Encryptor() encryption.Encryptor

    }
}


namespace blobtesting {
    class ConcurrentAccessOptions << (S,Aquamarine) >> {
        + NumBlobs int
        + Getters int
        + Putters int
        + Deleters int
        + Listers int
        + Iterations int
        + RangeGetPercentage int
        + NonExistentListPrefixPercentage int

    }
    class FaultyStorage << (S,Aquamarine) >> {
        + GetCapacity(ctx context.Context) (blob.Capacity, error)
        + GetBlob(ctx context.Context, id blob.ID, offset int64, length int64, output blob.OutputBuffer) error
        + GetMetadata(ctx context.Context, id blob.ID) (blob.Metadata, error)
        + PutBlob(ctx context.Context, id blob.ID, data blob.Bytes, opts blob.PutOptions) error
        + DeleteBlob(ctx context.Context, id blob.ID) error
        + ListBlobs(ctx context.Context, prefix blob.ID, callback <font color=blue>func</font>(blob.Metadata) error) error
        + Close(ctx context.Context) error
        + ConnectionInfo() blob.ConnectionInfo
        + DisplayName() string
        + FlushCaches(ctx context.Context) error

    }
    class blobtesting.DataMap << (T, #FF7700) >>  {
    }
    class blobtesting.versionedEntries << (T, #FF7700) >>  {
    }
    class ecCacheEntry << (S,Aquamarine) >> {
    }
    class ecFrontendCache << (S,Aquamarine) >> {
    }
    class entry << (S,Aquamarine) >> {
    }
    class eventuallyConsistentStorage << (S,Aquamarine) >> {
        + GetCapacity(ctx context.Context) (blob.Capacity, error)
        + GetBlob(ctx context.Context, id blob.ID, offset int64, length int64, output blob.OutputBuffer) error
        + GetMetadata(ctx context.Context, id blob.ID) (blob.Metadata, error)
        + PutBlob(ctx context.Context, id blob.ID, data blob.Bytes, opts blob.PutOptions) error
        + DeleteBlob(ctx context.Context, id blob.ID) error
        + ListBlobs(ctx context.Context, prefix blob.ID, callback <font color=blue>func</font>(blob.Metadata) error) error
        + Close(ctx context.Context) error
        + ConnectionInfo() blob.ConnectionInfo
        + DisplayName() string
        + FlushCaches(ctx context.Context) error

    }
    class mapStorage << (S,Aquamarine) >> {
        + GetCapacity(ctx context.Context) (blob.Capacity, error)
        + GetBlob(ctx context.Context, id blob.ID, offset int64, length int64, output blob.OutputBuffer) error
        + GetMetadata(ctx context.Context, id blob.ID) (blob.Metadata, error)
        + PutBlob(ctx context.Context, id blob.ID, data blob.Bytes, opts blob.PutOptions) error
        + DeleteBlob(ctx context.Context, id blob.ID) error
        + ListBlobs(ctx context.Context, prefix blob.ID, callback <font color=blue>func</font>(blob.Metadata) error) error
        + Close(ctx context.Context) error
        + TouchBlob(ctx context.Context, blobID blob.ID, threshold time.Duration) (time.Time, error)
        + ConnectionInfo() blob.ConnectionInfo
        + DisplayName() string
        + FlushCaches(ctx context.Context) error

    }
    class objectLockingMap << (S,Aquamarine) >> {
        + GetCapacity(ctx context.Context) (blob.Capacity, error)
        + GetBlob(ctx context.Context, id blob.ID, offset int64, length int64, output blob.OutputBuffer) error
        + GetMetadata(ctx context.Context, id blob.ID) (blob.Metadata, error)
        + PutBlob(ctx context.Context, id blob.ID, data blob.Bytes, opts blob.PutOptions) error
        + DeleteBlob(ctx context.Context, id blob.ID) error
        + ListBlobs(ctx context.Context, prefix blob.ID, callback <font color=blue>func</font>(blob.Metadata) error) error
        + Close(ctx context.Context) error
        + TouchBlob(ctx context.Context, id blob.ID, threshold time.Duration) (time.Time, error)
        + ConnectionInfo() blob.ConnectionInfo
        + DisplayName() string
        + FlushCaches(ctx context.Context) error

    }
    class "<font color=blue>map</font>[blob.ID][]*entry" as fontcolorbluemapfontblobIDentry {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
}
"fault.Set" *-- "blobtesting.FaultyStorage"

"blob.Storage" <|-- "blobtesting.FaultyStorage"
"blob.Volume" <|-- "blobtesting.FaultyStorage"
"blob.Storage" <|-- "blobtesting.eventuallyConsistentStorage"
"blob.Volume" <|-- "blobtesting.eventuallyConsistentStorage"
"blob.Storage" <|-- "blobtesting.mapStorage"
"blob.Volume" <|-- "blobtesting.mapStorage"
"cache.Storage" <|-- "blobtesting.mapStorage"
"blob.Storage" <|-- "blobtesting.objectLockingMap"
"blob.Volume" <|-- "blobtesting.objectLockingMap"
"cache.Storage" <|-- "blobtesting.objectLockingMap"

namespace cache {
    interface ContentCache  {
        + Close(ctx context.Context) 
        + GetContent(ctx context.Context, contentID string, blobID blob.ID, offset int64, length int64, output *gather.WriteBuffer) error
        + PrefetchBlob(ctx context.Context, blobID blob.ID) error
        + CacheStorage() Storage

    }
    class Options << (S,Aquamarine) >> {
        + BaseCacheDirectory string
        + CacheSubDir string
        + Storage Storage
        + HMACSecret []byte
        + FetchFullBlobs bool
        + Sweep SweepSettings
        + TimeNow <font color=blue>func</font>() time.Time

    }
    class PersistentCache << (S,Aquamarine) >> {
        + CacheStorage() Storage
        + GetFetchingMutex(id blob.ID) *sync.RWMutex
        + GetOrLoad(ctx context.Context, key string, fetch <font color=blue>func</font>(*gather.WriteBuffer) error, output *gather.WriteBuffer) error
        + GetFull(ctx context.Context, key string, output *gather.WriteBuffer) bool
        + GetPartial(ctx context.Context, key string, offset int64, length int64, output *gather.WriteBuffer) bool
        + Put(ctx context.Context, key string, data gather.Bytes) 
        + Close(ctx context.Context) 

    }
    interface Storage  {
        + TouchBlob(ctx context.Context, contentID blob.ID, threshold time.Duration) (time.Time, error)

    }
    class SweepSettings << (S,Aquamarine) >> {
        + MaxSizeBytes int64
        + MinSweepAge time.Duration
        + TouchThreshold time.Duration

    }
    class blobCacheEntry << (S,Aquamarine) >> {
    }
    class contentCacheImpl << (S,Aquamarine) >> {
        + GetContent(ctx context.Context, contentID string, blobID blob.ID, offset int64, length int64, output *gather.WriteBuffer) error
        + Close(ctx context.Context) 
        + PrefetchBlob(ctx context.Context, blobID blob.ID) error
        + CacheStorage() Storage

    }
    class contentMetadataHeap << (S,Aquamarine) >> {
        + Len() int
        + Less(i int, j int) bool
        + Swap(i int, j int) 
        + Push(x <font color=blue>interface</font>{}) 
        + Pop() <font color=blue>interface</font>{}
        + LookupByID(id blob.ID) (int, *blobCacheEntry)
        + DataSize() int64

    }
    class metricsStruct << (S,Aquamarine) >> {
    }
    class passthroughContentCache << (S,Aquamarine) >> {
        + Close(ctx context.Context) 
        + GetContent(ctx context.Context, contentID string, blobID blob.ID, offset int64, length int64, output *gather.WriteBuffer) error
        + PrefetchBlob(ctx context.Context, blobID blob.ID) error
        + Sync(ctx context.Context, blobPrefix blob.ID) error
        + CacheStorage() Storage

    }
}
"cache.metricsStruct" *-- "cache.PersistentCache"

"cache.ContentCache" <|-- "cache.contentCacheImpl"
"cache.ContentCache" <|-- "cache.passthroughContentCache"

namespace cachefs {
    class Cache << (S,Aquamarine) >> {
        + IterateEntries(ctx context.Context, d fs.Directory, w EntryWrapper, callback <font color=blue>func</font>(context.Context, fs.Entry) error) error

    }
    interface DirectoryCacher  {
        + IterateEntries(ctx context.Context, d fs.Directory, w EntryWrapper, callback <font color=blue>func</font>(context.Context, fs.Entry) error) error

    }
    class Options << (S,Aquamarine) >> {
        + MaxCachedDirectories int
        + MaxCachedEntries int

    }
    class cacheContext << (S,Aquamarine) >> {
    }
    class cacheEntry << (S,Aquamarine) >> {
    }
    class cachefs.EntryWrapper << (T, #FF7700) >>  {
    }
    class cachefs.Loader << (T, #FF7700) >>  {
    }
    class directory << (S,Aquamarine) >> {
        + Child(ctx context.Context, name string) (fs.Entry, error)
        + IterateEntries(ctx context.Context, callback <font color=blue>func</font>(context.Context, fs.Entry) error) error

    }
    class file << (S,Aquamarine) >> {
    }
    class symlink << (S,Aquamarine) >> {
    }
    class "<font color=blue>func</font>(context.Context) ([]fs.Entry, error)" as fontcolorbluefuncfontcontextContextfsEntryerror {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "<font color=blue>func</font>(fs.Entry) fs.Entry" as fontcolorbluefuncfontfsEntryfsEntry {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
}
"fs.Directory" *-- "cachefs.directory"
"fs.File" *-- "cachefs.file"
"fs.Symlink" *-- "cachefs.symlink"

"cachefs.DirectoryCacher" <|-- "cachefs.Cache"

namespace cacheprot {
    interface StorageProtection  {
        + Protect(id string, input gather.Bytes, output *gather.WriteBuffer) 
        + Verify(id string, input gather.Bytes, output *gather.WriteBuffer) error

    }
    class authenticatedEncryptionProtection << (S,Aquamarine) >> {
        + Protect(id string, input gather.Bytes, output *gather.WriteBuffer) 
        + Verify(id string, input gather.Bytes, output *gather.WriteBuffer) error

    }
    class authenticatedEncryptionProtectionKey << (S,Aquamarine) >> {
        + GetEncryptionAlgorithm() string
        + GetMasterKey() []byte

    }
    class cacheprot.authenticatedEncryptionProtectionKey << (T, #FF7700) >>  {
    }
    class checksumProtection << (S,Aquamarine) >> {
        + Secret []byte

        + Protect(id string, input gather.Bytes, output *gather.WriteBuffer) 
        + Verify(id string, input gather.Bytes, output *gather.WriteBuffer) error

    }
    class nullStorageProtection << (S,Aquamarine) >> {
        + Protect(id string, input gather.Bytes, output *gather.WriteBuffer) 
        + Verify(id string, input gather.Bytes, output *gather.WriteBuffer) error

    }
}

"cacheprot.StorageProtection" <|-- "cacheprot.authenticatedEncryptionProtection"
"encryption.Parameters" <|-- "cacheprot.authenticatedEncryptionProtectionKey"
"cacheprot.StorageProtection" <|-- "cacheprot.checksumProtection"
"cacheprot.StorageProtection" <|-- "cacheprot.nullStorageProtection"

namespace cli {
    class App << (S,Aquamarine) >> {
        + AdvancedCommands string

        + Stderr() io.Writer
        + SetLoggerFactory(loggerForModule logging.LoggerFactory) 
        + RegisterOnExit(f <font color=blue>func</font>() ) 
        + SetEnvNamePrefixForTesting(prefix string) 
        + EnvName(n string) string
        + Attach(app *kingpin.Application) 
        + RunSubcommand(ctx context.Context, kpapp *kingpin.Application, stdin io.Reader, argsAndFlags []string) (io.Reader, io.Reader, <font color=blue>func</font>() error, <font color=blue>func</font>() )
        + AddStorageProvider(p StorageProvider) 

    }
    class MaintenanceInfo << (S,Aquamarine) >> {
    }
    class RepositoryStatus << (S,Aquamarine) >> {
        + ConfigFile string
        + UniqueIDHex string
        + ClientOptions repo.ClientOptions
        + Storage blob.ConnectionInfo
        + Capacity *blob.Capacity
        + ContentFormat format.ContentFormat
        + ObjectFormat format.ObjectFormat
        + BlobRetention format.BlobStorageConfiguration

    }
    class SnapshotManifest << (S,Aquamarine) >> {
        + RetentionReasons []string

    }
    interface StorageFlags  {
        + Setup(sps StorageProviderServices, cmd *kingpin.CmdClause) 
        + Connect(ctx context.Context, isCreate bool, formatVersion int) (blob.Storage, error)

    }
    class StorageProvider << (S,Aquamarine) >> {
        + Name string
        + Description string
        + NewFlags <font color=blue>func</font>() StorageFlags

    }
    interface StorageProviderServices  {
        + EnvName(s string) string

    }
    class aclListItem << (S,Aquamarine) >> {
        + ID manifest.ID

    }
    interface advancedAppServices  {
    }
    interface appServices  {
        + Stderr() io.Writer
        + EnvName(s string) string

    }
    class cliProgress << (S,Aquamarine) >> {
        + HashingFile(fname string) 
        + FinishedHashingFile(fname string, totalSize int64) 
        + UploadedBytes(numBytes int64) 
        + HashedBytes(numBytes int64) 
        + Error(path string, err error, isIgnored bool) 
        + CachedFile(fname string, numBytes int64) 
        + StartShared() 
        + FinishShared() 
        + UploadStarted() 
        + EstimatedDataSize(fileCount int, totalBytes int64) 
        + UploadFinished() 
        + Finish() 

    }
    class commandACLAdd << (S,Aquamarine) >> {
    }
    class commandACLDelete << (S,Aquamarine) >> {
    }
    class commandACLEnable << (S,Aquamarine) >> {
    }
    class commandACLList << (S,Aquamarine) >> {
    }
    class commandBenchmark << (S,Aquamarine) >> {
    }
    class commandBenchmarkCompression << (S,Aquamarine) >> {
    }
    class commandBenchmarkCrypto << (S,Aquamarine) >> {
    }
    class commandBenchmarkEcc << (S,Aquamarine) >> {
    }
    class commandBenchmarkEncryption << (S,Aquamarine) >> {
    }
    class commandBenchmarkHashing << (S,Aquamarine) >> {
    }
    class commandBenchmarkSplitters << (S,Aquamarine) >> {
    }
    class commandBlob << (S,Aquamarine) >> {
    }
    class commandBlobDelete << (S,Aquamarine) >> {
    }
    class commandBlobGC << (S,Aquamarine) >> {
    }
    class commandBlobList << (S,Aquamarine) >> {
    }
    class commandBlobShards << (S,Aquamarine) >> {
    }
    class commandBlobShardsModify << (S,Aquamarine) >> {
    }
    class commandBlobShow << (S,Aquamarine) >> {
    }
    class commandBlobStats << (S,Aquamarine) >> {
    }
    class commandCache << (S,Aquamarine) >> {
    }
    class commandCacheClear << (S,Aquamarine) >> {
    }
    class commandCacheInfo << (S,Aquamarine) >> {
    }
    class commandCachePrefetch << (S,Aquamarine) >> {
    }
    class commandCacheSetParams << (S,Aquamarine) >> {
    }
    class commandCacheSync << (S,Aquamarine) >> {
    }
    class commandContent << (S,Aquamarine) >> {
    }
    class commandContentDelete << (S,Aquamarine) >> {
    }
    class commandContentList << (S,Aquamarine) >> {
    }
    class commandContentRewrite << (S,Aquamarine) >> {
    }
    class commandContentShow << (S,Aquamarine) >> {
    }
    class commandContentStats << (S,Aquamarine) >> {
    }
    class commandContentVerify << (S,Aquamarine) >> {
    }
    class commandDiff << (S,Aquamarine) >> {
    }
    class commandIndex << (S,Aquamarine) >> {
    }
    class commandIndexEpoch << (S,Aquamarine) >> {
    }
    class commandIndexEpochList << (S,Aquamarine) >> {
    }
    class commandIndexInspect << (S,Aquamarine) >> {
    }
    class commandIndexList << (S,Aquamarine) >> {
    }
    class commandIndexOptimize << (S,Aquamarine) >> {
    }
    class commandIndexRecover << (S,Aquamarine) >> {
    }
    class commandList << (S,Aquamarine) >> {
    }
    class commandLogs << (S,Aquamarine) >> {
    }
    class commandLogsCleanup << (S,Aquamarine) >> {
    }
    class commandLogsList << (S,Aquamarine) >> {
    }
    class commandLogsShow << (S,Aquamarine) >> {
    }
    class commandMaintenance << (S,Aquamarine) >> {
    }
    class commandMaintenanceInfo << (S,Aquamarine) >> {
    }
    class commandMaintenanceRun << (S,Aquamarine) >> {
    }
    class commandMaintenanceSet << (S,Aquamarine) >> {
    }
    class commandManifest << (S,Aquamarine) >> {
    }
    class commandManifestDelete << (S,Aquamarine) >> {
    }
    class commandManifestList << (S,Aquamarine) >> {
    }
    class commandManifestShow << (S,Aquamarine) >> {
    }
    class commandMount << (S,Aquamarine) >> {
    }
    interface commandParent  {
        + Command(name string, help string) *kingpin.CmdClause

    }
    class commandPolicy << (S,Aquamarine) >> {
    }
    class commandPolicyDelete << (S,Aquamarine) >> {
    }
    class commandPolicyEdit << (S,Aquamarine) >> {
    }
    class commandPolicyList << (S,Aquamarine) >> {
    }
    class commandPolicySet << (S,Aquamarine) >> {
    }
    class commandPolicyShow << (S,Aquamarine) >> {
    }
    class commandRepository << (S,Aquamarine) >> {
    }
    class commandRepositoryChangePassword << (S,Aquamarine) >> {
    }
    class commandRepositoryConnect << (S,Aquamarine) >> {
    }
    class commandRepositoryConnectServer << (S,Aquamarine) >> {
    }
    class commandRepositoryCreate << (S,Aquamarine) >> {
    }
    class commandRepositoryDisconnect << (S,Aquamarine) >> {
    }
    class commandRepositoryRepair << (S,Aquamarine) >> {
    }
    class commandRepositorySetClient << (S,Aquamarine) >> {
    }
    class commandRepositorySetParameters << (S,Aquamarine) >> {
    }
    class commandRepositoryStatus << (S,Aquamarine) >> {
    }
    class commandRepositorySyncTo << (S,Aquamarine) >> {
    }
    class commandRepositoryThrottle << (S,Aquamarine) >> {
    }
    class commandRepositoryThrottleGet << (S,Aquamarine) >> {
    }
    class commandRepositoryThrottleSet << (S,Aquamarine) >> {
    }
    class commandRepositoryUpgrade << (S,Aquamarine) >> {
    }
    class commandRepositoryValidateProvider << (S,Aquamarine) >> {
    }
    class commandRestore << (S,Aquamarine) >> {
    }
    class commandServer << (S,Aquamarine) >> {
    }
    class commandServerACL << (S,Aquamarine) >> {
    }
    class commandServerCancel << (S,Aquamarine) >> {
    }
    class commandServerFlush << (S,Aquamarine) >> {
    }
    class commandServerPause << (S,Aquamarine) >> {
    }
    class commandServerRefresh << (S,Aquamarine) >> {
    }
    class commandServerResume << (S,Aquamarine) >> {
    }
    class commandServerShutdown << (S,Aquamarine) >> {
    }
    class commandServerSourceManagerAction << (S,Aquamarine) >> {
    }
    class commandServerStart << (S,Aquamarine) >> {
    }
    class commandServerStatus << (S,Aquamarine) >> {
    }
    class commandServerThrottle << (S,Aquamarine) >> {
    }
    class commandServerThrottleGet << (S,Aquamarine) >> {
    }
    class commandServerThrottleSet << (S,Aquamarine) >> {
    }
    class commandServerUpload << (S,Aquamarine) >> {
    }
    class commandServerUser << (S,Aquamarine) >> {
    }
    class commandServerUserAddSet << (S,Aquamarine) >> {
    }
    class commandServerUserDelete << (S,Aquamarine) >> {
    }
    class commandServerUserInfo << (S,Aquamarine) >> {
    }
    class commandServerUserList << (S,Aquamarine) >> {
    }
    class commandSession << (S,Aquamarine) >> {
    }
    class commandSessionList << (S,Aquamarine) >> {
    }
    class commandShow << (S,Aquamarine) >> {
    }
    class commandSnapshot << (S,Aquamarine) >> {
    }
    class commandSnapshotCopyMoveHistory << (S,Aquamarine) >> {
    }
    class commandSnapshotCreate << (S,Aquamarine) >> {
    }
    class commandSnapshotDelete << (S,Aquamarine) >> {
    }
    class commandSnapshotEstimate << (S,Aquamarine) >> {
    }
    class commandSnapshotExpire << (S,Aquamarine) >> {
    }
    class commandSnapshotFix << (S,Aquamarine) >> {
    }
    class commandSnapshotFixInvalidFiles << (S,Aquamarine) >> {
    }
    class commandSnapshotFixRemoveFiles << (S,Aquamarine) >> {
    }
    class commandSnapshotList << (S,Aquamarine) >> {
    }
    class commandSnapshotMigrate << (S,Aquamarine) >> {
    }
    class commandSnapshotPin << (S,Aquamarine) >> {
    }
    class commandSnapshotRestore << (S,Aquamarine) >> {
    }
    class commandSnapshotVerify << (S,Aquamarine) >> {
    }
    class commonRewriteSnapshots << (S,Aquamarine) >> {
    }
    class commonThrottleGet << (S,Aquamarine) >> {
    }
    class commonThrottleSet << (S,Aquamarine) >> {
    }
    class compressionBechmarkResult << (S,Aquamarine) >> {
    }
    class connectOptions << (S,Aquamarine) >> {
    }
    class contentRangeFlags << (S,Aquamarine) >> {
    }
    class contentStatsTotals << (S,Aquamarine) >> {
    }
    class cryptoBenchResult << (S,Aquamarine) >> {
    }
    class eccBenchResult << (S,Aquamarine) >> {
    }
    class estimateProgress << (S,Aquamarine) >> {
        + Processing(ctx context.Context, dirname string) 
        + Error(ctx context.Context, filename string, err error, isIgnored bool) 
        + Stats(ctx context.Context, st *snapshot.Stats, included snapshotfs.SampleBuckets, excluded snapshotfs.SampleBuckets, excludedDirs []string, final bool) 

    }
    class indexBlobPlusContentInfo << (S,Aquamarine) >> {
    }
    class jsonList << (S,Aquamarine) >> {
    }
    class jsonOutput << (S,Aquamarine) >> {
    }
    class logSelectionCriteria << (S,Aquamarine) >> {
    }
    class logSessionInfo << (S,Aquamarine) >> {
    }
    class observabilityFlags << (S,Aquamarine) >> {
    }
    class policyActionFlags << (S,Aquamarine) >> {
    }
    class policyCompressionFlags << (S,Aquamarine) >> {
    }
    class policyErrorFlags << (S,Aquamarine) >> {
    }
    class policyFilesFlags << (S,Aquamarine) >> {
    }
    class policyLoggingFlags << (S,Aquamarine) >> {
    }
    class policyRetentionFlags << (S,Aquamarine) >> {
    }
    class policySchedulingFlags << (S,Aquamarine) >> {
    }
    class policyTableRow << (S,Aquamarine) >> {
    }
    class policyTargetFlags << (S,Aquamarine) >> {
    }
    class policyUploadFlags << (S,Aquamarine) >> {
    }
    class profileFlags << (S,Aquamarine) >> {
    }
    class progressFlags << (S,Aquamarine) >> {
    }
    class repositoryAccessMode << (S,Aquamarine) >> {
    }
    class restoreSourceTarget << (S,Aquamarine) >> {
    }
    class serverClientFlags << (S,Aquamarine) >> {
    }
    class serverFlags << (S,Aquamarine) >> {
    }
    class snapshotListRow << (S,Aquamarine) >> {
    }
    class storageAzureFlags << (S,Aquamarine) >> {
        + Setup(svc StorageProviderServices, cmd *kingpin.CmdClause) 
        + Connect(ctx context.Context, isCreate bool, formatVersion int) (blob.Storage, error)

    }
    class storageB2Flags << (S,Aquamarine) >> {
        + Setup(svc StorageProviderServices, cmd *kingpin.CmdClause) 
        + Connect(ctx context.Context, isCreate bool, formatVersion int) (blob.Storage, error)

    }
    class storageFilesystemFlags << (S,Aquamarine) >> {
        + Setup(_ StorageProviderServices, cmd *kingpin.CmdClause) 
        + Connect(ctx context.Context, isCreate bool, formatVersion int) (blob.Storage, error)

    }
    class storageFromConfigFlags << (S,Aquamarine) >> {
        + Setup(sps StorageProviderServices, cmd *kingpin.CmdClause) 
        + Connect(ctx context.Context, isCreate bool, formatVersion int) (blob.Storage, error)

    }
    class storageGCSFlags << (S,Aquamarine) >> {
        + Setup(_ StorageProviderServices, cmd *kingpin.CmdClause) 
        + Connect(ctx context.Context, isCreate bool, formatVersion int) (blob.Storage, error)

    }
    class storageGDriveFlags << (S,Aquamarine) >> {
        + Setup(_ StorageProviderServices, cmd *kingpin.CmdClause) 
        + Connect(ctx context.Context, isCreate bool, formatVersion int) (blob.Storage, error)

    }
    class storageRcloneFlags << (S,Aquamarine) >> {
        + Setup(_ StorageProviderServices, cmd *kingpin.CmdClause) 
        + Connect(ctx context.Context, isCreate bool, formatVersion int) (blob.Storage, error)

    }
    class storageS3Flags << (S,Aquamarine) >> {
        + Setup(svc StorageProviderServices, cmd *kingpin.CmdClause) 
        + Connect(ctx context.Context, isCreate bool, formatVersion int) (blob.Storage, error)

    }
    class storageSFTPFlags << (S,Aquamarine) >> {
        + Setup(_ StorageProviderServices, cmd *kingpin.CmdClause) 
        + Connect(ctx context.Context, isCreate bool, formatVersion int) (blob.Storage, error)

    }
    class storageWebDAVFlags << (S,Aquamarine) >> {
        + Setup(svc StorageProviderServices, cmd *kingpin.CmdClause) 
        + Connect(ctx context.Context, isCreate bool, formatVersion int) (blob.Storage, error)

    }
    class textOutput << (S,Aquamarine) >> {
    }
    class updateState << (S,Aquamarine) >> {
        + NextCheckTime time.Time
        + NextNotifyTime time.Time
        + AvailableVersion string

    }
}
"maintenance.Params" *-- "cli.MaintenanceInfo"
"maintenance.Schedule" *-- "cli.MaintenanceInfo"
"snapshot.Manifest" *-- "cli.SnapshotManifest"
"acl.Entry" *-- "cli.aclListItem"
"cli.StorageProviderServices" *-- "cli.advancedAppServices"
"cli.appServices" *-- "cli.advancedAppServices"
"cli.progressFlags" *-- "cli.cliProgress"
"snapshotfs.NullUploadProgress" *-- "cli.cliProgress"
"cli.policyTargetFlags" *-- "cli.commandPolicyDelete"
"cli.policyTargetFlags" *-- "cli.commandPolicyEdit"
"cli.policyActionFlags" *-- "cli.commandPolicySet"
"cli.policyCompressionFlags" *-- "cli.commandPolicySet"
"cli.policyErrorFlags" *-- "cli.commandPolicySet"
"cli.policyFilesFlags" *-- "cli.commandPolicySet"
"cli.policyLoggingFlags" *-- "cli.commandPolicySet"
"cli.policyRetentionFlags" *-- "cli.commandPolicySet"
"cli.policySchedulingFlags" *-- "cli.commandPolicySet"
"cli.policyTargetFlags" *-- "cli.commandPolicySet"
"cli.policyUploadFlags" *-- "cli.commandPolicySet"
"cli.policyTargetFlags" *-- "cli.commandPolicyShow"
"cli.commandServerSourceManagerAction" *-- "cli.commandServerCancel"
"cli.commandServerSourceManagerAction" *-- "cli.commandServerPause"
"cli.commandServerSourceManagerAction" *-- "cli.commandServerResume"
"cli.commandServerSourceManagerAction" *-- "cli.commandServerUpload"
"cli.commandRestore" *-- "cli.commandSnapshotRestore"

"cli.StorageProviderServices" <|-- "cli.App"
"cli.advancedAppServices" <|-- "cli.App"
"cli.appServices" <|-- "cli.App"
"snapshotfs.EstimateProgress" <|-- "cli.estimateProgress"
"cli.StorageFlags" <|-- "cli.storageAzureFlags"
"cli.StorageFlags" <|-- "cli.storageB2Flags"
"cli.StorageFlags" <|-- "cli.storageFilesystemFlags"
"cli.StorageFlags" <|-- "cli.storageFromConfigFlags"
"cli.StorageFlags" <|-- "cli.storageGCSFlags"
"cli.StorageFlags" <|-- "cli.storageGDriveFlags"
"cli.StorageFlags" <|-- "cli.storageRcloneFlags"
"cli.StorageFlags" <|-- "cli.storageS3Flags"
"cli.StorageFlags" <|-- "cli.storageSFTPFlags"
"cli.StorageFlags" <|-- "cli.storageWebDAVFlags"

namespace compression {
    interface Compressor  {
        + HeaderID() HeaderID
        + Compress(output io.Writer, input io.Reader) error
        + Decompress(output io.Writer, input io.Reader, withHeader bool) error

    }
    class compression.HeaderID << (T, #FF7700) >>  {
    }
    class compression.Name << (T, #FF7700) >>  {
    }
    class deflateCompressor << (S,Aquamarine) >> {
        + HeaderID() HeaderID
        + Compress(output io.Writer, input io.Reader) error
        + Decompress(output io.Writer, input io.Reader, withHeader bool) error

    }
    class gzipCompressor << (S,Aquamarine) >> {
        + HeaderID() HeaderID
        + Compress(output io.Writer, input io.Reader) error
        + Decompress(output io.Writer, input io.Reader, withHeader bool) error

    }
    class lz4Compressor << (S,Aquamarine) >> {
        + HeaderID() HeaderID
        + Compress(output io.Writer, input io.Reader) error
        + Decompress(output io.Writer, input io.Reader, withHeader bool) error

    }
    class pgzipCompressor << (S,Aquamarine) >> {
        + HeaderID() HeaderID
        + Compress(output io.Writer, input io.Reader) error
        + Decompress(output io.Writer, input io.Reader, withHeader bool) error

    }
    class s2Compressor << (S,Aquamarine) >> {
        + HeaderID() HeaderID
        + Compress(output io.Writer, input io.Reader) error
        + Decompress(output io.Writer, input io.Reader, withHeader bool) error

    }
    class zstdCompressor << (S,Aquamarine) >> {
        + HeaderID() HeaderID
        + Compress(output io.Writer, input io.Reader) error
        + Decompress(output io.Writer, input io.Reader, withHeader bool) error

    }
}

"compression.Compressor" <|-- "compression.deflateCompressor"
"compression.Compressor" <|-- "compression.gzipCompressor"
"compression.Compressor" <|-- "compression.lz4Compressor"
"compression.Compressor" <|-- "compression.pgzipCompressor"
"compression.Compressor" <|-- "compression.s2Compressor"
"compression.Compressor" <|-- "compression.zstdCompressor"

namespace connection {
    interface Connection  {
    }
    interface ConnectorImpl  {
        + NewConnection(ctx context.Context) (Connection, error)
        + IsConnectionClosedError(err error) bool

    }
    class Reconnector << (S,Aquamarine) >> {
        + GetOrOpenConnection(ctx context.Context) (Connection, error)
        + UsingConnectionNoResult(ctx context.Context, desc string, cb <font color=blue>func</font>(Connection) error) error
        + CloseActiveConnection(ctx context.Context) 

    }
}


namespace content {
    class CachingOptions << (S,Aquamarine) >> {
        + CacheDirectory string
        + MaxCacheSizeBytes int64
        + MaxMetadataCacheSizeBytes int64
        + MaxListCacheDuration DurationSeconds
        + MinMetadataSweepAge DurationSeconds
        + MinContentSweepAge DurationSeconds
        + MinIndexSweepAge DurationSeconds
        + HMACSecret []byte

        + CloneOrDefault() *CachingOptions
        + CacheSubdirOrEmpty(subdir string) string

    }
    class DurationSeconds << (S,Aquamarine) >> {
        + DurationOrDefault(def time.Duration) time.Duration

    }
    interface IndexBlobReader  {
        + ListIndexBlobInfos( context.Context) ([]indexblob.Metadata, time.Time, error)

    }
    class IterateOptions << (S,Aquamarine) >> {
        + Range IDRange
        + IncludeDeleted bool
        + Parallel int

    }
    class IteratePackOptions << (S,Aquamarine) >> {
        + IncludePacksWithOnlyDeletedContent bool
        + IncludeContentInfos bool
        + Prefixes []blob.ID

    }
    class ManagerOptions << (S,Aquamarine) >> {
        + TimeNow <font color=blue>func</font>() time.Time
        + DisableInternalLog bool
        + RetentionMode string
        + RetentionPeriod time.Duration
        + PermissiveCacheLoading bool

        + CloneOrDefault() *ManagerOptions

    }
    class PackInfo << (S,Aquamarine) >> {
        + PackID blob.ID
        + ContentCount int
        + TotalSize int64
        + ContentInfos []Info

    }
    interface Reader  {
        + SupportsContentCompression() (bool, error)
        + ContentFormat() format.Provider
        + GetContent(ctx context.Context, id ID) ([]byte, error)
        + ContentInfo(ctx context.Context, id ID) (Info, error)
        + IterateContents(ctx context.Context, opts IterateOptions, callback IterateCallback) error
        + IteratePacks(ctx context.Context, opts IteratePackOptions, callback IteratePacksCallback) error
        + ListActiveSessions(ctx context.Context) (<font color=blue>map</font>[SessionID]*{packageName}SessionInfo, error)
        + EpochManager() (*epoch.Manager, bool, error)

    }
    class SessionInfo << (S,Aquamarine) >> {
        + ID SessionID
        + StartTime time.Time
        + CheckpointTime time.Time
        + User string
        + Host string

    }
    class SessionOptions << (S,Aquamarine) >> {
        + SessionUser string
        + SessionHost string
        + OnUpload <font color=blue>func</font>(int64) 

    }
    class SharedManager << (S,Aquamarine) >> {
        + Stats *Stats

        + LoadIndexBlob(ctx context.Context, ibid blob.ID, d *gather.WriteBuffer) ([]Info, error)
        + IndexReaderV0() IndexBlobReader
        + IndexReaderV1() IndexBlobReader
        + IndexBlobs(ctx context.Context, includeInactive bool) ([]indexblob.Metadata, error)
        + EpochManager() (*epoch.Manager, bool, error)
        + CloseShared(ctx context.Context) error
        + AlsoLogToContentLog(ctx context.Context) context.Context
        + PrepareUpgradeToIndexBlobManagerV1(ctx context.Context, params epoch.Parameters) error
        + Refresh(ctx context.Context) error
        + CompactIndexes(ctx context.Context, opt indexblob.CompactOptions) error

    }
    class Stats << (S,Aquamarine) >> {
        + Reset() 
        + ReadContent() (uint32, int64)
        + WrittenContent() (uint32, int64)
        + HashedContent() (uint32, int64)
        + DecryptedBytes() int64
        + EncryptedBytes() int64
        + InvalidContents() uint32
        + ValidContents() uint32

    }
    class WriteManager << (S,Aquamarine) >> {
        + RecoverIndexFromPackBlob(ctx context.Context, packFile blob.ID, packFileLength int64, commit bool) ([]Info, error)
        + Revision() int64
        + DeleteContent(ctx context.Context, contentID ID) error
        + DisableIndexFlush(ctx context.Context) 
        + EnableIndexFlush(ctx context.Context) 
        + ContentFormat() format.Provider
        + Flush(ctx context.Context) error
        + RewriteContent(ctx context.Context, contentID ID) error
        + UndeleteContent(ctx context.Context, contentID ID) error
        + SupportsContentCompression() (bool, error)
        + WriteContent(ctx context.Context, data gather.Bytes, prefix index.IDPrefix, comp compression.HeaderID) (ID, error)
        + GetContent(ctx context.Context, contentID ID) ([]byte, error)
        + ContentInfo(ctx context.Context, contentID ID) (Info, error)
        + DisableIndexRefresh() 
        + MetadataCache() cache.ContentCache
        + IterateContents(ctx context.Context, opts IterateOptions, callback IterateCallback) error
        + IteratePacks(ctx context.Context, options IteratePackOptions, callback IteratePacksCallback) error
        + IterateUnreferencedBlobs(ctx context.Context, blobPrefixes []blob.ID, parallellism int, callback <font color=blue>func</font>(blob.Metadata) error) error
        + PrefetchContents(ctx context.Context, contentIDs []ID, hint string) []ID
        + ListActiveSessions(ctx context.Context) (<font color=blue>map</font>[SessionID]*{packageName}SessionInfo, error)

    }
    class committedContentIndex << (S,Aquamarine) >> {
    }
    interface committedContentIndexCache  {
    }
    class content.DurationSeconds << (T, #FF7700) >>  {
    }
    class content.ID << (T, #FF7700) >>  {
    }
    class content.IDPrefix << (T, #FF7700) >>  {
    }
    class content.IDRange << (T, #FF7700) >>  {
    }
    class content.Info << (T, #FF7700) >>  {
    }
    class content.InfoStruct << (T, #FF7700) >>  {
    }
    class content.IterateCallback << (T, #FF7700) >>  {
    }
    class content.IteratePacksCallback << (T, #FF7700) >>  {
    }
    class content.SessionID << (T, #FF7700) >>  {
    }
    class content.cancelIterateFunc << (T, #FF7700) >>  {
    }
    class deletedInfo << (S,Aquamarine) >> {
        + GetDeleted() bool
        + GetTimestampSeconds() int64

    }
    class diskCommittedContentIndexCache << (S,Aquamarine) >> {
    }
    class epochParameters << (S,Aquamarine) >> {
        + GetParameters() (*epoch.Parameters, error)

    }
    class memoryCommittedContentIndexCache << (S,Aquamarine) >> {
    }
    class metricsStruct << (S,Aquamarine) >> {
    }
    class packContentPostamble << (S,Aquamarine) >> {
    }
    class pendingPackInfo << (S,Aquamarine) >> {
    }
    class prefetchOptions << (S,Aquamarine) >> {
    }
    class "index.ID" as indexID {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "index.IDPrefix" as indexIDPrefix {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "index.IDRange" as indexIDRange {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "index.Info" as indexInfo {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "index.InfoStruct" as indexInfoStruct {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
}
"content.metricsStruct" *-- "content.SharedManager"
"content.SharedManager" *-- "content.WriteManager"
"content.Info" *-- "content.deletedInfo"

"object.contentReader" <|-- "content.WriteManager"
"content.committedContentIndexCache" <|-- "content.diskCommittedContentIndexCache"
"epoch.ParametersProvider" <|-- "content.epochParameters"
"content.committedContentIndexCache" <|-- "content.memoryCommittedContentIndexCache"

namespace ctxutil {
    class detachedContext << (S,Aquamarine) >> {
        + Value(key <font color=blue>interface</font>{}) <font color=blue>interface</font>{}

    }
}
"context.Context" *-- "ctxutil.detachedContext"


namespace diff {
    class Comparer << (S,Aquamarine) >> {
        + DiffCommand string
        + DiffArguments []string

        + Compare(ctx context.Context, e1 fs.Entry, e2 fs.Entry) error
        + Close() error

    }
}


namespace dirutil {
    interface OSInterface  {
        + Mkdir(dirname string, perm fs.FileMode) error
        + IsExist(err error) bool
        + IsNotExist(err error) bool
        + IsPathSeparator(s byte) bool

    }
}


namespace ecc {
    class Options << (S,Aquamarine) >> {
        + Algorithm string
        + OverheadPercent int
        + MaxShardSize int
        + DeleteFirstShardForTests bool

    }
    interface Parameters  {
        + GetECCAlgorithm() string
        + GetECCOverheadPercent() int

    }
    class ReedSolomonCrcECC << (S,Aquamarine) >> {
        + DataShards int
        + ParityShards int
        + ThresholdParityInput int
        + ThresholdParityOutput int
        + ThresholdBlocksInput int
        + ThresholdBlocksOutput int

        + Encrypt(input gather.Bytes, contentID []byte, output *gather.WriteBuffer) error
        + Decrypt(input gather.Bytes, contentID []byte, output *gather.WriteBuffer) error
        + Overhead() int

    }
    class ecc.CreateECCFunc << (T, #FF7700) >>  {
    }
    class sizesInfo << (S,Aquamarine) >> {
        + Blocks int
        + ShardSize int
        + DataShards int
        + ParityShards int
        + StorePadding bool

    }
    class "<font color=blue>func</font>(*Options) (encryption.Encryptor, error)" as fontcolorbluefuncfontOptionsencryptionEncryptorerror {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
}
"ecc.Options" *-- "ecc.ReedSolomonCrcECC"

"encryption.Encryptor" <|-- "ecc.ReedSolomonCrcECC"

namespace encryption {
    interface Encryptor  {
        + Encrypt(plainText gather.Bytes, contentID []byte, output *gather.WriteBuffer) error
        + Decrypt(cipherText gather.Bytes, contentID []byte, output *gather.WriteBuffer) error
        + Overhead() int

    }
    interface Parameters  {
        + GetEncryptionAlgorithm() string
        + GetMasterKey() []byte

    }
    class aes256GCMHmacSha256 << (S,Aquamarine) >> {
        + Decrypt(input gather.Bytes, contentID []byte, output *gather.WriteBuffer) error
        + Encrypt(input gather.Bytes, contentID []byte, output *gather.WriteBuffer) error
        + Overhead() int

    }
    class chacha20poly1305hmacSha256Encryptor << (S,Aquamarine) >> {
        + Decrypt(input gather.Bytes, contentID []byte, output *gather.WriteBuffer) error
        + Encrypt(input gather.Bytes, contentID []byte, output *gather.WriteBuffer) error
        + Overhead() int

    }
    class encryption.EncryptorFactory << (T, #FF7700) >>  {
    }
    class encryptorInfo << (S,Aquamarine) >> {
    }
}

"encryption.Encryptor" <|-- "encryption.aes256GCMHmacSha256"
"encryption.Encryptor" <|-- "encryption.chacha20poly1305hmacSha256Encryptor"

namespace epoch {
    class CurrentSnapshot << (S,Aquamarine) >> {
        + WriteEpoch int
        + UncompactedEpochSets <font color=blue>map</font>[int][]blob.Metadata
        + LongestRangeCheckpointSets []*RangeMetadata
        + SingleEpochCompactionSets <font color=blue>map</font>[int][]blob.Metadata
        + EpochStartTime <font color=blue>map</font>[int]time.Time
        + DeletionWatermark time.Time
        + ValidUntil time.Time
        + EpochMarkerBlobs []blob.Metadata
        + DeletionWatermarkBlobs []blob.Metadata

    }
    class Manager << (S,Aquamarine) >> {
        + Flush() 
        + Current(ctx context.Context) (CurrentSnapshot, error)
        + AdvanceDeletionWatermark(ctx context.Context, ts time.Time) error
        + ForceAdvanceEpoch(ctx context.Context) error
        + Refresh(ctx context.Context) error
        + CleanupSupersededIndexes(ctx context.Context) error
        + GetCompleteIndexSet(ctx context.Context, maxEpoch int) ([]blob.Metadata, time.Time, error)
        + WriteIndex(ctx context.Context, dataShards <font color=blue>map</font>[blob.ID]blob.Bytes) ([]blob.Metadata, error)
        + Invalidate() 

    }
    class Parameters << (S,Aquamarine) >> {
        + Enabled bool
        + EpochRefreshFrequency time.Duration
        + FullCheckpointFrequency int
        + CleanupSafetyMargin time.Duration
        + MinEpochDuration time.Duration
        + EpochAdvanceOnCountThreshold int
        + EpochAdvanceOnTotalSizeBytesThreshold int64
        + DeleteParallelism int

        + GetEpochManagerEnabled() bool
        + GetEpochRefreshFrequency() time.Duration
        + GetEpochFullCheckpointFrequency() int
        + GetEpochCleanupSafetyMargin() time.Duration
        + GetMinEpochDuration() time.Duration
        + GetEpochAdvanceOnCountThreshold() int
        + GetEpochAdvanceOnTotalSizeBytesThreshold() int64
        + GetEpochDeleteParallelism() int
        + Validate() error

    }
    interface ParametersProvider  {
        + GetParameters() (*Parameters, error)

    }
    class RangeMetadata << (S,Aquamarine) >> {
        + MinEpoch int
        + MaxEpoch int
        + Blobs []blob.Metadata

    }
    class epoch.CompactionFunc << (T, #FF7700) >>  {
    }
    class "<font color=blue>func</font>(context.Context, []blob.ID, blob.ID) error" as fontcolorbluefuncfontcontextContextblobIDblobIDerror {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
}


namespace faketime {
    class ClockTimeWithOffset << (S,Aquamarine) >> {
        + NowFunc() <font color=blue>func</font>() time.Time
        + Advance(dt time.Duration) time.Time

    }
    class TimeAdvance << (S,Aquamarine) >> {
        + NowFunc() <font color=blue>func</font>() time.Time
        + Advance(dt time.Duration) time.Time

    }
}


namespace fault {
    class Fault << (S,Aquamarine) >> {
        + ErrorInstead(err error) *Fault
        + ErrorCallbackInstead(cb <font color=blue>func</font>() error) *Fault
        + Before(cb <font color=blue>func</font>() ) *Fault
        + Repeat(n int) *Fault
        + SleepFor(d time.Duration) *Fault

    }
    class Set << (S,Aquamarine) >> {
        + AddFault(method Method) *Fault
        + AddFaults(method Method, faults ...*Fault) 
        + NumCalls(method Method) int
        + VerifyAllFaultsExercised(t *testing.T) 
        + GetNextFault(ctx context.Context, method Method, args ...<font color=blue>interface</font>{}) (bool, error)

    }
    class fault.Method << (T, #FF7700) >>  {
    }
}


namespace feature {
    class IfNotUnderstood << (S,Aquamarine) >> {
        + Warn bool
        + Message string
        + URL string
        + UpgradeToVersion string

    }
    class Required << (S,Aquamarine) >> {
        + Feature Feature
        + IfNotUnderstood IfNotUnderstood

        + UnsupportedMessage() string

    }
    class feature.Behavior << (T, #FF7700) >>  {
    }
    class feature.Feature << (T, #FF7700) >>  {
    }
}


namespace filesystem {
    class Options << (S,Aquamarine) >> {
        + Path string
        + FileMode os.FileMode
        + DirectoryMode os.FileMode
        + FileUID *int
        + FileGID *int

    }
    class fsImpl << (S,Aquamarine) >> {
        + GetBlobFromPath(ctx context.Context, dirPath string, path string, offset int64, length int64, output blob.OutputBuffer) error
        + GetMetadataFromPath(ctx context.Context, dirPath string, path string) (blob.Metadata, error)
        + PutBlobInPath(ctx context.Context, dirPath string, path string, data blob.Bytes, opts blob.PutOptions) error
        + DeleteBlobInPath(ctx context.Context, dirPath string, path string) error
        + ReadDir(ctx context.Context, dirname string) ([]os.FileInfo, error)

    }
    class fsStorage << (S,Aquamarine) >> {
        + TouchBlob(ctx context.Context, blobID blob.ID, threshold time.Duration) (time.Time, error)
        + ConnectionInfo() blob.ConnectionInfo
        + DisplayName() string
        + Close(ctx context.Context) error
        + FlushCaches(ctx context.Context) error
        + GetCapacity(ctx context.Context) (blob.Capacity, error)
        + GetCapacity(ctx context.Context) (blob.Capacity, error)
        + GetCapacity(ctx context.Context) (blob.Capacity, error)

    }
    interface osInterface  {
        + Open(fname string) (osReadFile, error)
        + IsNotExist(err error) bool
        + IsExist(err error) bool
        + IsPathError(err error) bool
        + IsLinkError(err error) bool
        + IsPathSeparator(c byte) bool
        + Remove(fname string) error
        + Rename(oldname string, newname string) error
        + ReadDir(dirname string) ([]fs.DirEntry, error)
        + Stat(fname string) (os.FileInfo, error)
        + CreateNewFile(fname string, mode os.FileMode) (osWriteFile, error)
        + Mkdir(fname string, mode os.FileMode) error
        + MkdirAll(fname string, mode os.FileMode) error
        + Chtimes(fname string, atime time.Time, mtime time.Time) error
        + Geteuid() int
        + Chown(fname string, uid int, gid int) error
        + IsESTALE(err error) bool

    }
    interface osReadFile  {
        + Stat() (os.FileInfo, error)

    }
    interface osWriteFile  {
    }
    class realOS << (S,Aquamarine) >> {
        + Open(fname string) (osReadFile, error)
        + IsNotExist(err error) bool
        + IsExist(err error) bool
        + IsPathSeparator(c byte) bool
        + Rename(oldname string, newname string) error
        + ReadDir(dirname string) ([]fs.DirEntry, error)
        + IsPathError(err error) bool
        + IsLinkError(err error) bool
        + Remove(fname string) error
        + Stat(fname string) (os.FileInfo, error)
        + CreateNewFile(fname string, perm os.FileMode) (osWriteFile, error)
        + Mkdir(fname string, mode os.FileMode) error
        + MkdirAll(fname string, mode os.FileMode) error
        + Chtimes(fname string, atime time.Time, mtime time.Time) error
        + Geteuid() int
        + Chown(fname string, uid int, gid int) error
        + IsESTALE(err error) bool
        + IsESTALE(err error) bool

    }
}
"sharded.Options" *-- "filesystem.Options"
"throttling.Limits" *-- "filesystem.Options"
"filesystem.Options" *-- "filesystem.fsImpl"
"sharded.Storage" *-- "filesystem.fsStorage"

"sharded.Impl" <|-- "filesystem.fsImpl"
"blob.Volume" <|-- "filesystem.fsStorage"
"cache.Storage" <|-- "filesystem.fsStorage"
"filesystem.osInterface" <|-- "filesystem.realOS"

namespace format {
    class BlobStorageConfiguration << (S,Aquamarine) >> {
        + RetentionMode blob.RetentionMode
        + RetentionPeriod time.Duration

        + IsRetentionEnabled() bool
        + Validate() error

    }
    class ContentFormat << (S,Aquamarine) >> {
        + Hash string
        + Encryption string
        + ECC string
        + ECCOverheadPercent int
        + HMACSecret []byte
        + MasterKey []byte
        + EnablePasswordChange bool

        + ResolveFormatVersion() error
        + GetMutableParameters() (MutableParameters, error)
        + SupportsPasswordChange() bool
        + GetEncryptionAlgorithm() string
        + GetMasterKey() []byte
        + GetECCAlgorithm() string
        + GetECCOverheadPercent() int
        + GetHashFunction() string
        + GetHmacSecret() []byte

    }
    class EncryptedRepositoryConfig << (S,Aquamarine) >> {
        + Format RepositoryConfig

    }
    class KopiaRepositoryJSON << (S,Aquamarine) >> {
        + Tool string
        + BuildVersion string
        + BuildInfo string
        + UniqueID []byte
        + KeyDerivationAlgorithm string
        + EncryptionAlgorithm string
        + EncryptedFormatBytes []byte

        + WriteBlobCfgBlob(ctx context.Context, st blob.Storage, blobcfg BlobStorageConfiguration, formatEncryptionKey []byte) error
        + DeriveFormatEncryptionKeyFromPassword(password string) ([]byte, error)
        + DeriveFormatEncryptionKeyFromPassword(password string) ([]byte, error)
        + WriteKopiaRepositoryBlob(ctx context.Context, st blob.Storage, blobCfg BlobStorageConfiguration) error
        + WriteKopiaRepositoryBlobWithID(ctx context.Context, st blob.Storage, blobCfg BlobStorageConfiguration, id blob.ID) error
        + EncryptRepositoryConfig(format *RepositoryConfig, masterKey []byte) error

    }
    class Manager << (S,Aquamarine) >> {
        + ChangePassword(ctx context.Context, newPassword string) error
        + ValidCacheDuration() time.Duration
        + RefreshCount() int
        + GetEncryptionAlgorithm() string
        + GetHashFunction() string
        + GetECCAlgorithm() string
        + GetECCOverheadPercent() int
        + GetHmacSecret() []byte
        + HashFunc() hashing.HashFunc
        + Encryptor() encryption.Encryptor
        + GetMasterKey() []byte
        + SupportsPasswordChange() bool
        + RepositoryFormatBytes() ([]byte, error)
        + GetMutableParameters() (MutableParameters, error)
        + UpgradeLockIntent() (*UpgradeLockIntent, error)
        + RequiredFeatures() ([]feature.Required, error)
        + LoadedTime() time.Time
        + UniqueID() []byte
        + BlobCfgBlob() (BlobStorageConfiguration, error)
        + ObjectFormat() ObjectFormat
        + FormatEncryptionKey() []byte
        + ScrubbedContentFormat() ContentFormat
        + SetParameters(ctx context.Context, mp MutableParameters, blobcfg BlobStorageConfiguration, requiredFeatures []feature.Required) error
        + SetUpgradeLockIntent(ctx context.Context, l UpgradeLockIntent) (*UpgradeLockIntent, error)
        + CommitUpgrade(ctx context.Context) error
        + RollbackUpgrade(ctx context.Context) error
        + GetUpgradeLockIntent(ctx context.Context) (*UpgradeLockIntent, error)

    }
    class MutableParameters << (S,Aquamarine) >> {
        + Version Version
        + MaxPackSize int
        + IndexVersion int
        + EpochParameters epoch.Parameters

        + Validate() error

    }
    class ObjectFormat << (S,Aquamarine) >> {
        + Splitter string

    }
    interface Provider  {
        + HashFunc() hashing.HashFunc
        + Encryptor() encryption.Encryptor
        + GetMutableParameters() (MutableParameters, error)
        + SupportsPasswordChange() bool
        + GetMasterKey() []byte
        + RepositoryFormatBytes() ([]byte, error)

    }
    class RepositoryConfig << (S,Aquamarine) >> {
        + UpgradeLock *UpgradeLockIntent
        + RequiredFeatures []feature.Required

    }
    class UpgradeLockIntent << (S,Aquamarine) >> {
        + OwnerID string
        + CreationTime time.Time
        + AdvanceNoticeDuration time.Duration
        + IODrainTimeout time.Duration
        + StatusPollInterval time.Duration
        + Message string
        + MaxPermittedClockDrift time.Duration

        + Update(other *UpgradeLockIntent) (*UpgradeLockIntent, error)
        + Clone() *UpgradeLockIntent
        + Validate() error
        + UpgradeTime() time.Time
        + IsLocked(now time.Time) (bool, bool)

    }
    interface blobCache  {
        + Get(ctx context.Context, blobID blob.ID) ([]byte, time.Time, bool)
        + Put(ctx context.Context, blobID blob.ID, data []byte) (time.Time, error)
        + Remove(ctx context.Context, ids []blob.ID) 

    }
    class encryptorWrapper << (S,Aquamarine) >> {
        + Encrypt(plainText gather.Bytes, contentID []byte, output *gather.WriteBuffer) error
        + Decrypt(cipherText gather.Bytes, contentID []byte, output *gather.WriteBuffer) error
        + Overhead() int

    }
    class format.Version << (T, #FF7700) >>  {
    }
    class formattingOptionsProvider << (S,Aquamarine) >> {
        + Encryptor() encryption.Encryptor
        + HashFunc() hashing.HashFunc
        + RepositoryFormatBytes() ([]byte, error)

    }
    class inMemoryCache << (S,Aquamarine) >> {
        + Get(ctx context.Context, blobID blob.ID) ([]byte, time.Time, bool)
        + Put(ctx context.Context, blobID blob.ID, data []byte) (time.Time, error)
        + Remove(ctx context.Context, ids []blob.ID) 

    }
    class nullCache << (S,Aquamarine) >> {
        + Get(ctx context.Context, blobID blob.ID) ([]byte, time.Time, bool)
        + Put(ctx context.Context, blobID blob.ID, data []byte) (time.Time, error)
        + Remove(ctx context.Context, ids []blob.ID) 

    }
    class onDiskCache << (S,Aquamarine) >> {
        + Get(ctx context.Context, blobID blob.ID) ([]byte, time.Time, bool)
        + Put(ctx context.Context, blobID blob.ID, data []byte) (time.Time, error)
        + Remove(ctx context.Context, ids []blob.ID) 

    }
}
"format.MutableParameters" *-- "format.ContentFormat"
"format.ContentFormat" *-- "format.RepositoryConfig"
"format.ObjectFormat" *-- "format.RepositoryConfig"
"format.ContentFormat" *-- "format.formattingOptionsProvider"

"ecc.Parameters" <|-- "format.ContentFormat"
"encryption.Parameters" <|-- "format.ContentFormat"
"hashing.Parameters" <|-- "format.ContentFormat"
"indexblob.IndexFormattingOptions" <|-- "format.ContentFormat"
"blobcrypto.Crypter" <|-- "format.Manager"
"ecc.Parameters" <|-- "format.Manager"
"encryption.Parameters" <|-- "format.Manager"
"format.Provider" <|-- "format.Manager"
"hashing.Parameters" <|-- "format.Manager"
"indexblob.IndexFormattingOptions" <|-- "format.Manager"
"encryption.Encryptor" <|-- "format.encryptorWrapper"
"blobcrypto.Crypter" <|-- "format.formattingOptionsProvider"
"format.blobCache" <|-- "format.inMemoryCache"
"format.blobCache" <|-- "format.nullCache"
"format.blobCache" <|-- "format.onDiskCache"

namespace freepool {
    class _freepool << (S,Aquamarine) >> {
        + Take() *T
        + Return(v *T) 

    }
    class Pool << (S,Aquamarine) >> {
    }
}


namespace fs {
    class DeviceInfo << (S,Aquamarine) >> {
        + Dev uint64
        + Rdev uint64

    }
    interface Directory  {
        + Child(ctx context.Context, name string) (Entry, error)
        + IterateEntries(ctx context.Context, cb <font color=blue>func</font>(context.Context, Entry) error) error
        + SupportsMultipleIterations() bool

    }
    class DirectorySummary << (S,Aquamarine) >> {
        + TotalFileSize int64
        + TotalFileCount int64
        + TotalSymlinkCount int64
        + TotalDirCount int64
        + MaxModTime UTCTimestamp
        + IncompleteReason string
        + FatalErrorCount int
        + IgnoredErrorCount int
        + FailedEntries []*EntryWithError

        + Clone() DirectorySummary

    }
    interface DirectoryWithSummary  {
        + Summary(ctx context.Context) (*DirectorySummary, error)

    }
    interface Entry  {
        + Owner() OwnerInfo
        + Device() DeviceInfo
        + LocalFilesystemPath() string
        + Close() 

    }
    class EntryWithError << (S,Aquamarine) >> {
        + EntryPath string
        + Error string

    }
    interface ErrorEntry  {
        + ErrorInfo() error

    }
    interface File  {
        + Open(ctx context.Context) (Reader, error)

    }
    class OwnerInfo << (S,Aquamarine) >> {
        + UserID uint32
        + GroupID uint32

    }
    interface Reader  {
        + Entry() (Entry, error)

    }
    interface StreamingFile  {
        + GetReader(ctx context.Context) (io.ReadCloser, error)

    }
    interface Symlink  {
        + Readlink(ctx context.Context) (string, error)

    }
    class UTCTimestamp << (S,Aquamarine) >> {
        + UnmarshalJSON(v []byte) error
        + MarshalJSON() ([]byte, error)
        + ToTime() time.Time
        + Add(dur time.Duration) UTCTimestamp
        + Sub(u2 UTCTimestamp) time.Duration
        + After(other UTCTimestamp) bool
        + Before(other UTCTimestamp) bool
        + Equal(other UTCTimestamp) bool
        + Format(layout string) string

    }
    class fs.UTCTimestamp << (T, #FF7700) >>  {
    }
}
"fs.Entry" *-- "fs.Directory"
"fs.Entry" *-- "fs.ErrorEntry"
"fs.Entry" *-- "fs.File"
"fs.Entry" *-- "fs.StreamingFile"
"fs.Entry" *-- "fs.Symlink"


namespace fusemount {
    class fuseDirectoryNode << (S,Aquamarine) >> {
        + Lookup(ctx context.Context, fileName string, out *fuse.EntryOut) (*fs.Inode, syscall.Errno)
        + Readdir(ctx context.Context) (fs.DirStream, syscall.Errno)

    }
    class fuseFileHandle << (S,Aquamarine) >> {
        + Read(ctx context.Context, dest []byte, off int64) (fuse.ReadResult, syscall.Errno)
        + Release(ctx context.Context) syscall.Errno

    }
    class fuseFileNode << (S,Aquamarine) >> {
        + Open(ctx context.Context, flags uint32) (fs.FileHandle, uint32, syscall.Errno)

    }
    class fuseNode << (S,Aquamarine) >> {
        + Getattr(ctx context.Context, fh fs.FileHandle, a *fuse.AttrOut) syscall.Errno

    }
    class fuseSymlinkNode << (S,Aquamarine) >> {
        + Readlink(ctx context.Context) ([]byte, syscall.Errno)

    }
}
"fusemount.fuseNode" *-- "fusemount.fuseDirectoryNode"
"fusemount.fuseNode" *-- "fusemount.fuseFileNode"
"fs.Inode" *-- "fusemount.fuseNode"
"fusemount.fuseNode" *-- "fusemount.fuseSymlinkNode"


namespace gather {
    class Bytes << (S,Aquamarine) >> {
        + Slices [][]byte

        + AppendSectionTo(w io.Writer, offset int, size int) error
        + Length() int
        + ReadAt(p []byte, off int64) (int, error)
        + Reader() io.ReadSeekCloser
        + AppendToSlice(output []byte) []byte
        + ToByteSlice() []byte
        + WriteTo(w io.Writer) (int64, error)

    }
    class WriteBuffer << (S,Aquamarine) >> {
        + Close() 
        + MakeContiguous(length int) []byte
        + Reset() 
        + Write(data []byte) (int, error)
        + AppendSectionTo(w io.Writer, offset int, size int) error
        + Length() int
        + ToByteSlice() []byte
        + Bytes() Bytes
        + Append(data []byte) 
        + Dup() *WriteBuffer

    }
    class bytesReadSeekCloser << (S,Aquamarine) >> {
        + Close() error
        + Read(buf []byte) (int, error)
        + Seek(offset int64, whence int) (int64, error)

    }
    class chunkAllocator << (S,Aquamarine) >> {
    }
}

"blob.Bytes" <|-- "gather.Bytes"
"blob.OutputBuffer" <|-- "gather.WriteBuffer"

namespace gcs {
    class Options << (S,Aquamarine) >> {
        + BucketName string
        + Prefix string
        + ServiceAccountCredentialsFile string
        + ServiceAccountCredentialJSON json.RawMessage
        + ReadOnly bool

    }
    class gcsStorage << (S,Aquamarine) >> {
        + GetCapacity(ctx context.Context) (blob.Capacity, error)
        + GetBlob(ctx context.Context, b blob.ID, offset int64, length int64, output blob.OutputBuffer) error
        + GetMetadata(ctx context.Context, b blob.ID) (blob.Metadata, error)
        + PutBlob(ctx context.Context, b blob.ID, data blob.Bytes, opts blob.PutOptions) error
        + DeleteBlob(ctx context.Context, b blob.ID) error
        + ListBlobs(ctx context.Context, prefix blob.ID, callback <font color=blue>func</font>(blob.Metadata) error) error
        + ConnectionInfo() blob.ConnectionInfo
        + DisplayName() string
        + Close(ctx context.Context) error
        + FlushCaches(ctx context.Context) error

    }
}
"throttling.Limits" *-- "gcs.Options"
"gcs.Options" *-- "gcs.gcsStorage"

"blob.Storage" <|-- "gcs.gcsStorage"
"blob.Volume" <|-- "gcs.gcsStorage"

namespace gdrive {
    class Options << (S,Aquamarine) >> {
        + FolderID string
        + ServiceAccountCredentialsFile string
        + ServiceAccountCredentialJSON json.RawMessage
        + ReadOnly bool

    }
    class cacheEntry << (S,Aquamarine) >> {
        + Mut sync.Mutex
        + BlobID blob.ID
        + FileID string

    }
    class changeEntry << (S,Aquamarine) >> {
        + BlobID blob.ID
        + FileID string

    }
    class fileIDCache << (S,Aquamarine) >> {
        + Blobs sync.Map

        + Lookup(blobID blob.ID, callback <font color=blue>func</font>(*cacheEntry) (<font color=blue>interface</font>{}, error)) (<font color=blue>interface</font>{}, error)
        + BlindPut(blobID blob.ID, fileID string) 
        + RecordBlobChange(blobID blob.ID, fileID string) 
        + VisitBlobChanges(callback <font color=blue>func</font>(blob.ID, string) ) 
        + Clear() 

    }
    class gdriveStorage << (S,Aquamarine) >> {
        + GetCapacity(ctx context.Context) (blob.Capacity, error)
        + GetBlob(ctx context.Context, b blob.ID, offset int64, length int64, output blob.OutputBuffer) error
        + GetMetadata(ctx context.Context, blobID blob.ID) (blob.Metadata, error)
        + PutBlob(ctx context.Context, blobID blob.ID, data blob.Bytes, opts blob.PutOptions) error
        + DeleteBlob(ctx context.Context, blobID blob.ID) error
        + ListBlobs(ctx context.Context, prefix blob.ID, callback <font color=blue>func</font>(blob.Metadata) error) error
        + ConnectionInfo() blob.ConnectionInfo
        + DisplayName() string
        + Close(ctx context.Context) error
        + FlushCaches(ctx context.Context) error

    }
}
"throttling.Limits" *-- "gdrive.Options"
"gdrive.Options" *-- "gdrive.gdriveStorage"

"blob.Storage" <|-- "gdrive.gdriveStorage"
"blob.Volume" <|-- "gdrive.gdriveStorage"

namespace grpcapi {
    class ContentInfo << (S,Aquamarine) >> {
        + Id string
        + PackedLength uint32
        + TimestampSeconds int64
        + PackBlobId string
        + PackOffset uint32
        + Deleted bool
        + FormatVersion uint32
        + OriginalLength uint32

        + Reset() 
        + String() string
        + ProtoMessage() 
        + ProtoReflect() protoreflect.Message
        + Descriptor() ([]byte, []int)
        + GetId() string
        + GetPackedLength() uint32
        + GetTimestampSeconds() int64
        + GetPackBlobId() string
        + GetPackOffset() uint32
        + GetDeleted() bool
        + GetFormatVersion() uint32
        + GetOriginalLength() uint32

    }
    class DeleteManifestRequest << (S,Aquamarine) >> {
        + ManifestId string

        + Reset() 
        + String() string
        + ProtoMessage() 
        + ProtoReflect() protoreflect.Message
        + Descriptor() ([]byte, []int)
        + GetManifestId() string

    }
    class DeleteManifestResponse << (S,Aquamarine) >> {
        + Reset() 
        + String() string
        + ProtoMessage() 
        + ProtoReflect() protoreflect.Message
        + Descriptor() ([]byte, []int)

    }
    class ErrorResponse << (S,Aquamarine) >> {
        + Code ErrorResponse_Code
        + Message string

        + Reset() 
        + String() string
        + ProtoMessage() 
        + ProtoReflect() protoreflect.Message
        + Descriptor() ([]byte, []int)
        + GetCode() ErrorResponse_Code
        + GetMessage() string

    }
    class ErrorResponse_Code << (S,Aquamarine) >> {
        + Enum() *ErrorResponse_Code
        + String() string
        + Descriptor() protoreflect.EnumDescriptor
        + Type() protoreflect.EnumType
        + Number() protoreflect.EnumNumber
        + EnumDescriptor() ([]byte, []int)

    }
    class FindManifestsRequest << (S,Aquamarine) >> {
        + Labels <font color=blue>map</font>[string]string
        + PageSize int32

        + Reset() 
        + String() string
        + ProtoMessage() 
        + ProtoReflect() protoreflect.Message
        + Descriptor() ([]byte, []int)
        + GetLabels() <font color=blue>map</font>[string]string
        + GetPageSize() int32

    }
    class FindManifestsResponse << (S,Aquamarine) >> {
        + Metadata []*ManifestEntryMetadata

        + Reset() 
        + String() string
        + ProtoMessage() 
        + ProtoReflect() protoreflect.Message
        + Descriptor() ([]byte, []int)
        + GetMetadata() []*ManifestEntryMetadata

    }
    class FlushRequest << (S,Aquamarine) >> {
        + Reset() 
        + String() string
        + ProtoMessage() 
        + ProtoReflect() protoreflect.Message
        + Descriptor() ([]byte, []int)

    }
    class FlushResponse << (S,Aquamarine) >> {
        + Reset() 
        + String() string
        + ProtoMessage() 
        + ProtoReflect() protoreflect.Message
        + Descriptor() ([]byte, []int)

    }
    class GetContentInfoRequest << (S,Aquamarine) >> {
        + ContentId string

        + Reset() 
        + String() string
        + ProtoMessage() 
        + ProtoReflect() protoreflect.Message
        + Descriptor() ([]byte, []int)
        + GetContentId() string

    }
    class GetContentInfoResponse << (S,Aquamarine) >> {
        + Info *ContentInfo

        + Reset() 
        + String() string
        + ProtoMessage() 
        + ProtoReflect() protoreflect.Message
        + Descriptor() ([]byte, []int)
        + GetInfo() *ContentInfo

    }
    class GetContentRequest << (S,Aquamarine) >> {
        + ContentId string

        + Reset() 
        + String() string
        + ProtoMessage() 
        + ProtoReflect() protoreflect.Message
        + Descriptor() ([]byte, []int)
        + GetContentId() string

    }
    class GetContentResponse << (S,Aquamarine) >> {
        + Data []byte

        + Reset() 
        + String() string
        + ProtoMessage() 
        + ProtoReflect() protoreflect.Message
        + Descriptor() ([]byte, []int)
        + GetData() []byte

    }
    class GetManifestRequest << (S,Aquamarine) >> {
        + ManifestId string

        + Reset() 
        + String() string
        + ProtoMessage() 
        + ProtoReflect() protoreflect.Message
        + Descriptor() ([]byte, []int)
        + GetManifestId() string

    }
    class GetManifestResponse << (S,Aquamarine) >> {
        + JsonData []byte
        + Metadata *ManifestEntryMetadata

        + Reset() 
        + String() string
        + ProtoMessage() 
        + ProtoReflect() protoreflect.Message
        + Descriptor() ([]byte, []int)
        + GetJsonData() []byte
        + GetMetadata() *ManifestEntryMetadata

    }
    class InitializeSessionRequest << (S,Aquamarine) >> {
        + Purpose string
        + ReadOnly bool

        + Reset() 
        + String() string
        + ProtoMessage() 
        + ProtoReflect() protoreflect.Message
        + Descriptor() ([]byte, []int)
        + GetPurpose() string
        + GetReadOnly() bool

    }
    class InitializeSessionResponse << (S,Aquamarine) >> {
        + Parameters *RepositoryParameters

        + Reset() 
        + String() string
        + ProtoMessage() 
        + ProtoReflect() protoreflect.Message
        + Descriptor() ([]byte, []int)
        + GetParameters() *RepositoryParameters

    }
    interface KopiaRepositoryClient  {
        + Session(ctx context.Context, opts ...grpc.CallOption) (KopiaRepository_SessionClient, error)

    }
    interface KopiaRepositoryServer  {
        + Session( KopiaRepository_SessionServer) error

    }
    interface KopiaRepository_SessionClient  {
        + Send( *SessionRequest) error
        + Recv() (*SessionResponse, error)

    }
    interface KopiaRepository_SessionServer  {
        + Send( *SessionResponse) error
        + Recv() (*SessionRequest, error)

    }
    class ManifestEntryMetadata << (S,Aquamarine) >> {
        + Id string
        + ModTimeNanos int64
        + Length int32
        + Labels <font color=blue>map</font>[string]string

        + Reset() 
        + String() string
        + ProtoMessage() 
        + ProtoReflect() protoreflect.Message
        + Descriptor() ([]byte, []int)
        + GetId() string
        + GetModTimeNanos() int64
        + GetLength() int32
        + GetLabels() <font color=blue>map</font>[string]string

    }
    class PrefetchContentsRequest << (S,Aquamarine) >> {
        + ContentIds []string
        + Hint string

        + Reset() 
        + String() string
        + ProtoMessage() 
        + ProtoReflect() protoreflect.Message
        + Descriptor() ([]byte, []int)
        + GetContentIds() []string
        + GetHint() string

    }
    class PrefetchContentsResponse << (S,Aquamarine) >> {
        + ContentIds []string

        + Reset() 
        + String() string
        + ProtoMessage() 
        + ProtoReflect() protoreflect.Message
        + Descriptor() ([]byte, []int)
        + GetContentIds() []string

    }
    class PutManifestRequest << (S,Aquamarine) >> {
        + JsonData []byte
        + Labels <font color=blue>map</font>[string]string

        + Reset() 
        + String() string
        + ProtoMessage() 
        + ProtoReflect() protoreflect.Message
        + Descriptor() ([]byte, []int)
        + GetJsonData() []byte
        + GetLabels() <font color=blue>map</font>[string]string

    }
    class PutManifestResponse << (S,Aquamarine) >> {
        + ManifestId string

        + Reset() 
        + String() string
        + ProtoMessage() 
        + ProtoReflect() protoreflect.Message
        + Descriptor() ([]byte, []int)
        + GetManifestId() string

    }
    class RepositoryParameters << (S,Aquamarine) >> {
        + HashFunction string
        + HmacSecret []byte
        + Splitter string
        + SupportsContentCompression bool

        + Reset() 
        + String() string
        + ProtoMessage() 
        + ProtoReflect() protoreflect.Message
        + Descriptor() ([]byte, []int)
        + GetHashFunction() string
        + GetHmacSecret() []byte
        + GetSplitter() string
        + GetSupportsContentCompression() bool

    }
    class SessionRequest << (S,Aquamarine) >> {
        + RequestId int64
        + TraceContext <font color=blue>map</font>[string]string
        + Request isSessionRequest_Request

        + Reset() 
        + String() string
        + ProtoMessage() 
        + ProtoReflect() protoreflect.Message
        + Descriptor() ([]byte, []int)
        + GetRequestId() int64
        + GetTraceContext() <font color=blue>map</font>[string]string
        + GetRequest() isSessionRequest_Request
        + GetInitializeSession() *InitializeSessionRequest
        + GetGetContentInfo() *GetContentInfoRequest
        + GetFlush() *FlushRequest
        + GetWriteContent() *WriteContentRequest
        + GetGetContent() *GetContentRequest
        + GetGetManifest() *GetManifestRequest
        + GetPutManifest() *PutManifestRequest
        + GetFindManifests() *FindManifestsRequest
        + GetDeleteManifest() *DeleteManifestRequest
        + GetPrefetchContents() *PrefetchContentsRequest

    }
    class SessionRequest_DeleteManifest << (S,Aquamarine) >> {
        + DeleteManifest *DeleteManifestRequest

    }
    class SessionRequest_FindManifests << (S,Aquamarine) >> {
        + FindManifests *FindManifestsRequest

    }
    class SessionRequest_Flush << (S,Aquamarine) >> {
        + Flush *FlushRequest

    }
    class SessionRequest_GetContent << (S,Aquamarine) >> {
        + GetContent *GetContentRequest

    }
    class SessionRequest_GetContentInfo << (S,Aquamarine) >> {
        + GetContentInfo *GetContentInfoRequest

    }
    class SessionRequest_GetManifest << (S,Aquamarine) >> {
        + GetManifest *GetManifestRequest

    }
    class SessionRequest_InitializeSession << (S,Aquamarine) >> {
        + InitializeSession *InitializeSessionRequest

    }
    class SessionRequest_PrefetchContents << (S,Aquamarine) >> {
        + PrefetchContents *PrefetchContentsRequest

    }
    class SessionRequest_PutManifest << (S,Aquamarine) >> {
        + PutManifest *PutManifestRequest

    }
    class SessionRequest_WriteContent << (S,Aquamarine) >> {
        + WriteContent *WriteContentRequest

    }
    class SessionResponse << (S,Aquamarine) >> {
        + RequestId int64
        + HasMore bool
        + Response isSessionResponse_Response

        + Reset() 
        + String() string
        + ProtoMessage() 
        + ProtoReflect() protoreflect.Message
        + Descriptor() ([]byte, []int)
        + GetRequestId() int64
        + GetHasMore() bool
        + GetResponse() isSessionResponse_Response
        + GetError() *ErrorResponse
        + GetInitializeSession() *InitializeSessionResponse
        + GetGetContentInfo() *GetContentInfoResponse
        + GetFlush() *FlushResponse
        + GetWriteContent() *WriteContentResponse
        + GetGetContent() *GetContentResponse
        + GetGetManifest() *GetManifestResponse
        + GetPutManifest() *PutManifestResponse
        + GetFindManifests() *FindManifestsResponse
        + GetDeleteManifest() *DeleteManifestResponse
        + GetPrefetchContents() *PrefetchContentsResponse

    }
    class SessionResponse_DeleteManifest << (S,Aquamarine) >> {
        + DeleteManifest *DeleteManifestResponse

    }
    class SessionResponse_Error << (S,Aquamarine) >> {
        + Error *ErrorResponse

    }
    class SessionResponse_FindManifests << (S,Aquamarine) >> {
        + FindManifests *FindManifestsResponse

    }
    class SessionResponse_Flush << (S,Aquamarine) >> {
        + Flush *FlushResponse

    }
    class SessionResponse_GetContent << (S,Aquamarine) >> {
        + GetContent *GetContentResponse

    }
    class SessionResponse_GetContentInfo << (S,Aquamarine) >> {
        + GetContentInfo *GetContentInfoResponse

    }
    class SessionResponse_GetManifest << (S,Aquamarine) >> {
        + GetManifest *GetManifestResponse

    }
    class SessionResponse_InitializeSession << (S,Aquamarine) >> {
        + InitializeSession *InitializeSessionResponse

    }
    class SessionResponse_PrefetchContents << (S,Aquamarine) >> {
        + PrefetchContents *PrefetchContentsResponse

    }
    class SessionResponse_PutManifest << (S,Aquamarine) >> {
        + PutManifest *PutManifestResponse

    }
    class SessionResponse_WriteContent << (S,Aquamarine) >> {
        + WriteContent *WriteContentResponse

    }
    class UnimplementedKopiaRepositoryServer << (S,Aquamarine) >> {
        + Session( KopiaRepository_SessionServer) error

    }
    interface UnsafeKopiaRepositoryServer  {
    }
    class WriteContentRequest << (S,Aquamarine) >> {
        + Prefix string
        + Data []byte
        + Compression uint32

        + Reset() 
        + String() string
        + ProtoMessage() 
        + ProtoReflect() protoreflect.Message
        + Descriptor() ([]byte, []int)
        + GetPrefix() string
        + GetData() []byte
        + GetCompression() uint32

    }
    class WriteContentResponse << (S,Aquamarine) >> {
        + ContentId string

        + Reset() 
        + String() string
        + ProtoMessage() 
        + ProtoReflect() protoreflect.Message
        + Descriptor() ([]byte, []int)
        + GetContentId() string

    }
    class grpcapi.ErrorResponse_Code << (T, #FF7700) >>  {
    }
    interface isSessionRequest_Request  {
    }
    interface isSessionResponse_Response  {
    }
    class kopiaRepositoryClient << (S,Aquamarine) >> {
        + Session(ctx context.Context, opts ...grpc.CallOption) (KopiaRepository_SessionClient, error)

    }
    class kopiaRepositorySessionClient << (S,Aquamarine) >> {
        + Send(m *SessionRequest) error
        + Recv() (*SessionResponse, error)

    }
    class kopiaRepositorySessionServer << (S,Aquamarine) >> {
        + Send(m *SessionResponse) error
        + Recv() (*SessionRequest, error)

    }
}
"grpc.ClientStream" *-- "grpcapi.kopiaRepositorySessionClient"
"grpc.ServerStream" *-- "grpcapi.kopiaRepositorySessionServer"

"hashing.Parameters" <|-- "grpcapi.RepositoryParameters"
"grpcapi.isSessionRequest_Request" <|-- "grpcapi.SessionRequest_DeleteManifest"
"grpcapi.isSessionRequest_Request" <|-- "grpcapi.SessionRequest_FindManifests"
"grpcapi.isSessionRequest_Request" <|-- "grpcapi.SessionRequest_Flush"
"grpcapi.isSessionRequest_Request" <|-- "grpcapi.SessionRequest_GetContent"
"grpcapi.isSessionRequest_Request" <|-- "grpcapi.SessionRequest_GetContentInfo"
"grpcapi.isSessionRequest_Request" <|-- "grpcapi.SessionRequest_GetManifest"
"grpcapi.isSessionRequest_Request" <|-- "grpcapi.SessionRequest_InitializeSession"
"grpcapi.isSessionRequest_Request" <|-- "grpcapi.SessionRequest_PrefetchContents"
"grpcapi.isSessionRequest_Request" <|-- "grpcapi.SessionRequest_PutManifest"
"grpcapi.isSessionRequest_Request" <|-- "grpcapi.SessionRequest_WriteContent"
"grpcapi.isSessionResponse_Response" <|-- "grpcapi.SessionResponse_DeleteManifest"
"grpcapi.isSessionResponse_Response" <|-- "grpcapi.SessionResponse_Error"
"grpcapi.isSessionResponse_Response" <|-- "grpcapi.SessionResponse_FindManifests"
"grpcapi.isSessionResponse_Response" <|-- "grpcapi.SessionResponse_Flush"
"grpcapi.isSessionResponse_Response" <|-- "grpcapi.SessionResponse_GetContent"
"grpcapi.isSessionResponse_Response" <|-- "grpcapi.SessionResponse_GetContentInfo"
"grpcapi.isSessionResponse_Response" <|-- "grpcapi.SessionResponse_GetManifest"
"grpcapi.isSessionResponse_Response" <|-- "grpcapi.SessionResponse_InitializeSession"
"grpcapi.isSessionResponse_Response" <|-- "grpcapi.SessionResponse_PrefetchContents"
"grpcapi.isSessionResponse_Response" <|-- "grpcapi.SessionResponse_PutManifest"
"grpcapi.isSessionResponse_Response" <|-- "grpcapi.SessionResponse_WriteContent"
"grpcapi.KopiaRepositoryServer" <|-- "grpcapi.UnimplementedKopiaRepositoryServer"
"grpcapi.UnsafeKopiaRepositoryServer" <|-- "grpcapi.UnimplementedKopiaRepositoryServer"
"grpcapi.KopiaRepositoryClient" <|-- "grpcapi.kopiaRepositoryClient"
"grpcapi.KopiaRepository_SessionClient" <|-- "grpcapi.kopiaRepositorySessionClient"
"grpcapi.KopiaRepository_SessionServer" <|-- "grpcapi.kopiaRepositorySessionServer"

namespace hashing {
    interface Parameters  {
        + GetHashFunction() string
        + GetHmacSecret() []byte

    }
    class hashing.HashFunc << (T, #FF7700) >>  {
    }
    class hashing.HashFuncFactory << (T, #FF7700) >>  {
    }
    class "<font color=blue>func</font>([]byte, gather.Bytes) []byte" as fontcolorbluefuncfontbytegatherBytesbyte {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
}


namespace ignorefs {
    class ignoreContext << (S,Aquamarine) >> {
    }
    class ignoreDirectory << (S,Aquamarine) >> {
        + DirEntryOrNil(ctx context.Context) (*snapshot.DirEntry, error)
        + IterateEntries(ctx context.Context, callback <font color=blue>func</font>(context.Context, fs.Entry) error) error
        + Child(ctx context.Context, name string) (fs.Entry, error)

    }
    class ignorefs.IgnoreCallback << (T, #FF7700) >>  {
    }
    class ignorefs.Option << (T, #FF7700) >>  {
    }
    class "<font color=blue>func</font>(context.Context, string, fs.Entry, *policy.Tree) " as fontcolorbluefuncfontcontextContextstringfsEntrypolicyTree {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
}
"fs.Directory" *-- "ignorefs.ignoreDirectory"

"snapshot.HasDirEntryOrNil" <|-- "ignorefs.ignoreDirectory"

namespace index {
    class Builder << (S,Aquamarine) >> {
        + Clone() Builder
        + Add(i Info) 
        + Build(output io.Writer, version int) error
        + BuildStable(output io.Writer, version int) error
        + BuildShards(indexVersion int, stable bool, shardSize int) ([]gather.Bytes, <font color=blue>func</font>() , error)

    }
    class FormatV1 << (S,Aquamarine) >> {
        + Version byte
        + KeySize byte
        + EntrySize uint16
        + EntryCount uint32
        + Entries []<font color=blue>struct</font>{[]byte, indexEntryInfoV1}
        + ExtraData []byte

    }
    class FormatV2 << (S,Aquamarine) >> {
        + Header <font color=blue>struct</font>{byte, byte, uint16, uint32, uint32, uint32, uint32, uint32, uint32, uint32}
        + Entries []<font color=blue>struct</font>{[]byte, indexV2EntryInfo}
        + Packs []<font color=blue>struct</font>{byte, uint32}
        + Formats []indexV2FormatInfo
        + ExtraData []byte

    }
    class ID << (S,Aquamarine) >> {
        + MarshalJSON() ([]byte, error)
        + UnmarshalJSON(v []byte) error
        + Hash() []byte
        + AppendToLogBuffer(sb *logging.Buffer) 
        + Append(out []byte) []byte
        + String() string
        + Prefix() IDPrefix
        + HasPrefix() bool

    }
    class IDPrefix << (S,Aquamarine) >> {
        + ValidateSingle() error

    }
    class IDRange << (S,Aquamarine) >> {
        + StartID IDPrefix
        + EndID IDPrefix

        + Contains(id ID) bool

    }
    interface Index  {
        + ApproximateCount() int
        + GetInfo(contentID ID) (Info, error)
        + Iterate(r IDRange, cb <font color=blue>func</font>(Info) error) error

    }
    interface Info  {
        + GetContentID() ID
        + GetPackBlobID() blob.ID
        + GetTimestampSeconds() int64
        + Timestamp() time.Time
        + GetOriginalLength() uint32
        + GetPackedLength() uint32
        + GetPackOffset() uint32
        + GetDeleted() bool
        + GetFormatVersion() byte
        + GetCompressionHeaderID() compression.HeaderID
        + GetEncryptionKeyID() byte

    }
    class InfoStruct << (S,Aquamarine) >> {
        + ContentID ID
        + PackBlobID blob.ID
        + TimestampSeconds int64
        + OriginalLength uint32
        + PackedLength uint32
        + PackOffset uint32
        + Deleted bool
        + FormatVersion byte
        + CompressionHeaderID compression.HeaderID
        + EncryptionKeyID byte

        + GetContentID() ID
        + GetPackBlobID() blob.ID
        + GetTimestampSeconds() int64
        + GetOriginalLength() uint32
        + GetPackedLength() uint32
        + GetPackOffset() uint32
        + GetDeleted() bool
        + GetFormatVersion() byte
        + GetCompressionHeaderID() compression.HeaderID
        + GetEncryptionKeyID() byte
        + Timestamp() time.Time

    }
    class Merged << (S,Aquamarine) >> {
        + ApproximateCount() int
        + Close() error
        + GetInfo(id ID) (Info, error)
        + Iterate(r IDRange, cb <font color=blue>func</font>(Info) error) error

    }
    class index.Builder << (T, #FF7700) >>  {
    }
    class index.IDPrefix << (T, #FF7700) >>  {
    }
    class index.Merged << (T, #FF7700) >>  {
    }
    class index.nextInfoHeap << (T, #FF7700) >>  {
    }
    class indexBuilderV1 << (S,Aquamarine) >> {
    }
    class indexBuilderV2 << (S,Aquamarine) >> {
    }
    class indexEntryInfoV1 << (S,Aquamarine) >> {
        + GetContentID() ID
        + GetTimestampSeconds() int64
        + GetFormatVersion() byte
        + GetPackBlobID() blob.ID
        + GetDeleted() bool
        + GetPackOffset() uint32
        + GetPackedLength() uint32
        + GetOriginalLength() uint32
        + Timestamp() time.Time
        + GetCompressionHeaderID() compression.HeaderID
        + GetEncryptionKeyID() byte

    }
    class indexV1 << (S,Aquamarine) >> {
        + ApproximateCount() int
        + Iterate(r IDRange, cb <font color=blue>func</font>(Info) error) error
        + GetInfo(contentID ID) (Info, error)
        + Close() error

    }
    class indexV2 << (S,Aquamarine) >> {
        + ApproximateCount() int
        + Iterate(r IDRange, cb <font color=blue>func</font>(Info) error) error
        + GetInfo(contentID ID) (Info, error)
        + Close() error

    }
    class indexV2EntryInfo << (S,Aquamarine) >> {
        + GetContentID() ID
        + GetTimestampSeconds() int64
        + GetDeleted() bool
        + GetPackOffset() uint32
        + GetOriginalLength() uint32
        + GetPackedLength() uint32
        + GetFormatVersion() byte
        + GetCompressionHeaderID() compression.HeaderID
        + GetEncryptionKeyID() byte
        + GetPackBlobID() blob.ID
        + Timestamp() time.Time

    }
    class indexV2FormatInfo << (S,Aquamarine) >> {
    }
    class nextInfo << (S,Aquamarine) >> {
    }
    class nextInfoHeap << (S,Aquamarine) >> {
        + Len() int
        + Less(i int, j int) bool
        + Swap(i int, j int) 
        + Push(x <font color=blue>interface</font>{}) 
        + Pop() <font color=blue>interface</font>{}

    }
    class v1HeaderInfo << (S,Aquamarine) >> {
    }
    class v2HeaderInfo << (S,Aquamarine) >> {
    }
}

"index.Info" <|-- "index.InfoStruct"
"index.Index" <|-- "index.Merged"
"index.Info" <|-- "index.indexEntryInfoV1"
"index.Index" <|-- "index.indexV1"
"index.Index" <|-- "index.indexV2"
"index.Info" <|-- "index.indexV2EntryInfo"

namespace indexblob {
    class CompactOptions << (S,Aquamarine) >> {
        + MaxSmallBlobs int
        + AllIndexes bool
        + DropDeletedBefore time.Time
        + DropContents []index.ID
        + DisableEventualConsistencySafety bool

    }
    class EncryptionManager << (S,Aquamarine) >> {
        + GetEncryptedBlob(ctx context.Context, blobID blob.ID, output *gather.WriteBuffer) error
        + EncryptAndWriteBlob(ctx context.Context, data gather.Bytes, prefix blob.ID, suffix blob.ID) (blob.Metadata, error)

    }
    interface IndexFormattingOptions  {
        + GetMutableParameters() (format.MutableParameters, error)

    }
    interface Manager  {
        + WriteIndexBlobs(ctx context.Context, data []gather.Bytes, suffix blob.ID) ([]blob.Metadata, error)
        + ListActiveIndexBlobs(ctx context.Context) ([]Metadata, time.Time, error)
        + Compact(ctx context.Context, opts CompactOptions) error
        + Invalidate(ctx context.Context) 

    }
    class ManagerV0 << (S,Aquamarine) >> {
        + ListIndexBlobInfos(ctx context.Context) ([]Metadata, time.Time, error)
        + ListActiveIndexBlobs(ctx context.Context) ([]Metadata, time.Time, error)
        + Invalidate(ctx context.Context) 
        + Compact(ctx context.Context, opt CompactOptions) error
        + WriteIndexBlobs(ctx context.Context, dataShards []gather.Bytes, suffix blob.ID) ([]blob.Metadata, error)

    }
    class ManagerV1 << (S,Aquamarine) >> {
        + EpochMgr *epoch.Manager

        + ListIndexBlobInfos(ctx context.Context) ([]Metadata, time.Time, error)
        + ListActiveIndexBlobs(ctx context.Context) ([]Metadata, time.Time, error)
        + Invalidate(ctx context.Context) 
        + Compact(ctx context.Context, opt CompactOptions) error
        + CompactEpoch(ctx context.Context, blobIDs []blob.ID, outputPrefix blob.ID) error
        + WriteIndexBlobs(ctx context.Context, dataShards []gather.Bytes, suffix blob.ID) ([]blob.Metadata, error)
        + EpochManager() *epoch.Manager
        + PrepareUpgradeToIndexBlobManagerV1(ctx context.Context, params epoch.Parameters, v0 *ManagerV0) error

    }
    class Metadata << (S,Aquamarine) >> {
        + Superseded []blob.Metadata

    }
    class cleanupEntry << (S,Aquamarine) >> {
        + BlobIDs []blob.ID
        + CleanupScheduleTime time.Time

    }
    class compactionLogEntry << (S,Aquamarine) >> {
        + InputMetadata []blob.Metadata
        + OutputMetadata []blob.Metadata

    }
}
"blob.Metadata" *-- "indexblob.Metadata"

"content.IndexBlobReader" <|-- "indexblob.ManagerV0"
"indexblob.Manager" <|-- "indexblob.ManagerV0"
"content.IndexBlobReader" <|-- "indexblob.ManagerV1"
"indexblob.Manager" <|-- "indexblob.ManagerV1"

namespace listcache {
    class cachedList << (S,Aquamarine) >> {
        + ExpireAfter time.Time
        + Blobs []blob.Metadata

    }
    class listCacheStorage << (S,Aquamarine) >> {
        + ListBlobs(ctx context.Context, prefix blob.ID, cb <font color=blue>func</font>(blob.Metadata) error) error
        + PutBlob(ctx context.Context, blobID blob.ID, data blob.Bytes, opts blob.PutOptions) error
        + FlushCaches(ctx context.Context) error
        + DeleteBlob(ctx context.Context, blobID blob.ID) error

    }
}
"blob.Storage" *-- "listcache.listCacheStorage"


namespace localfs {
    class PlaceholderFilePath << (S,Aquamarine) >> {
        + DirEntryOrNil(ctx context.Context) (*snapshot.DirEntry, error)

    }
    class entryWithError << (S,Aquamarine) >> {
    }
    class fileWithMetadata << (S,Aquamarine) >> {
        + Entry() (fs.Entry, error)

    }
    class filesystemDirectory << (S,Aquamarine) >> {
        + SupportsMultipleIterations() bool
        + Size() int64
        + Child(ctx context.Context, name string) (fs.Entry, error)
        + IterateEntries(ctx context.Context, cb <font color=blue>func</font>(context.Context, fs.Entry) error) error
        + Close() 

    }
    class filesystemEntry << (S,Aquamarine) >> {
        + Name() string
        + IsDir() bool
        + Mode() os.FileMode
        + Size() int64
        + ModTime() time.Time
        + Sys() <font color=blue>interface</font>{}
        + Owner() fs.OwnerInfo
        + Device() fs.DeviceInfo
        + LocalFilesystemPath() string

    }
    class filesystemErrorEntry << (S,Aquamarine) >> {
        + ErrorInfo() error
        + Close() 

    }
    class filesystemFile << (S,Aquamarine) >> {
        + Open(ctx context.Context) (fs.Reader, error)
        + Close() 

    }
    class filesystemSymlink << (S,Aquamarine) >> {
        + Readlink(ctx context.Context) (string, error)
        + Close() 

    }
    class localfs.PlaceholderFilePath << (T, #FF7700) >>  {
    }
    class shallowFilesystemDirectory << (S,Aquamarine) >> {
        + Close() 
        + DirEntryOrNil(ctx context.Context) (*snapshot.DirEntry, error)
        + SupportsMultipleIterations() bool
        + Child(ctx context.Context, name string) (fs.Entry, error)
        + IterateEntries(ctx context.Context, cb <font color=blue>func</font>(context.Context, fs.Entry) error) error

    }
    class shallowFilesystemFile << (S,Aquamarine) >> {
        + Close() 
        + DirEntryOrNil(ctx context.Context) (*snapshot.DirEntry, error)
        + Open(ctx context.Context) (fs.Reader, error)

    }
}
"os.File" *-- "localfs.fileWithMetadata"
"localfs.filesystemEntry" *-- "localfs.filesystemDirectory"
"localfs.filesystemEntry" *-- "localfs.filesystemErrorEntry"
"localfs.filesystemEntry" *-- "localfs.filesystemFile"
"localfs.filesystemEntry" *-- "localfs.filesystemSymlink"
"localfs.filesystemEntry" *-- "localfs.shallowFilesystemDirectory"
"localfs.filesystemEntry" *-- "localfs.shallowFilesystemFile"

"snapshot.HasDirEntryOrNil" <|-- "localfs.PlaceholderFilePath"
"fs.Reader" <|-- "localfs.fileWithMetadata"
"fs.ErrorEntry" <|-- "localfs.filesystemErrorEntry"
"fs.File" <|-- "localfs.filesystemFile"
"fs.Symlink" <|-- "localfs.filesystemSymlink"
"snapshot.HasDirEntryOrNil" <|-- "localfs.shallowFilesystemDirectory"
"fs.File" <|-- "localfs.shallowFilesystemFile"
"snapshot.HasDirEntryOrNil" <|-- "localfs.shallowFilesystemFile"

namespace logfile {
    class loggingFlags << (S,Aquamarine) >> {
    }
    class onDemandFile << (S,Aquamarine) >> {
        + Sync() error
        + Write(b []byte) (int, error)

    }
}


namespace logging {
    class Buffer << (S,Aquamarine) >> {
        + Release() 
        + Reset() 
        + AppendByte(val byte) *Buffer
        + AppendString(val string) *Buffer
        + AppendTime(val time.Time, layout string) *Buffer
        + AppendBytes(val []byte) *Buffer
        + AppendBoolean(val bool) *Buffer
        + AppendInt32(val int32) *Buffer
        + AppendInt64(val int64) *Buffer
        + AppendInt(val int64, base int) *Buffer
        + AppendUint32(val uint32) *Buffer
        + AppendUint64(val uint64) *Buffer
        + AppendUint(val uint64, base int) *Buffer
        + String() string

    }
    class loggerCache << (S,Aquamarine) >> {
    }
    class logging.Logger << (T, #FF7700) >>  {
    }
    class logging.LoggerFactory << (T, #FF7700) >>  {
    }
    class logging.contextKey << (T, #FF7700) >>  {
    }
    class loggingStorage << (S,Aquamarine) >> {
        + GetBlob(ctx context.Context, id blob.ID, offset int64, length int64, output blob.OutputBuffer) error
        + GetCapacity(ctx context.Context) (blob.Capacity, error)
        + GetMetadata(ctx context.Context, id blob.ID) (blob.Metadata, error)
        + PutBlob(ctx context.Context, id blob.ID, data blob.Bytes, opts blob.PutOptions) error
        + DeleteBlob(ctx context.Context, id blob.ID) error
        + ListBlobs(ctx context.Context, prefix blob.ID, callback <font color=blue>func</font>(blob.Metadata) error) error
        + Close(ctx context.Context) error
        + ConnectionInfo() blob.ConnectionInfo
        + DisplayName() string
        + FlushCaches(ctx context.Context) error

    }
    class "*zap.SugaredLogger" as zapSugaredLogger {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
}

"blob.Storage" <|-- "logging.loggingStorage"
"blob.Volume" <|-- "logging.loggingStorage"

namespace loggingfs {
    class loggingDirectory << (S,Aquamarine) >> {
        + Child(ctx context.Context, name string) (fs.Entry, error)
        + IterateEntries(ctx context.Context, callback <font color=blue>func</font>(context.Context, fs.Entry) error) error

    }
    class loggingFile << (S,Aquamarine) >> {
    }
    class loggingOptions << (S,Aquamarine) >> {
    }
    class loggingSymlink << (S,Aquamarine) >> {
    }
    class loggingfs.Option << (T, #FF7700) >>  {
    }
}
"fs.Directory" *-- "loggingfs.loggingDirectory"
"fs.File" *-- "loggingfs.loggingFile"
"fs.Symlink" *-- "loggingfs.loggingSymlink"


namespace main {
    class ToolInfo << (S,Aquamarine) >> {
    }
}


namespace maintenance {
    class CycleParams << (S,Aquamarine) >> {
        + Enabled bool
        + Interval time.Duration

    }
    class DeleteUnreferencedBlobsOptions << (S,Aquamarine) >> {
        + Parallel int
        + Prefix blob.ID
        + DryRun bool
        + NotAfterTime time.Time

    }
    class LogRetentionOptions << (S,Aquamarine) >> {
        + MaxTotalSize int64
        + MaxCount int
        + MaxAge time.Duration
        + DryRun bool
        + TimeFunc <font color=blue>func</font>() time.Time

        + OrDefault() LogRetentionOptions

    }
    class NotOwnedError << (S,Aquamarine) >> {
        + Owner string

        + Error() string

    }
    class Params << (S,Aquamarine) >> {
        + Owner string
        + QuickCycle CycleParams
        + FullCycle CycleParams
        + LogRetention LogRetentionOptions

    }
    class RewriteContentsOptions << (S,Aquamarine) >> {
        + Parallel int
        + ContentIDs []content.ID
        + ContentIDRange content.IDRange
        + PackPrefix blob.ID
        + ShortPacks bool
        + FormatVersion int
        + DryRun bool

    }
    class RunInfo << (S,Aquamarine) >> {
        + Start time.Time
        + End time.Time
        + Success bool
        + Error string

    }
    class RunParameters << (S,Aquamarine) >> {
        + Mode Mode
        + Params *Params
        + MaintenanceStartTime time.Time

    }
    class SafetyParameters << (S,Aquamarine) >> {
        + RewriteMinAge time.Duration
        + MinContentAgeSubjectToGC time.Duration
        + MarginBetweenSnapshotGC time.Duration
        + RequireTwoGCCycles bool
        + DisableEventualConsistencySafety bool
        + DropContentFromIndexExtraMargin time.Duration
        + BlobDeleteMinAge time.Duration
        + SessionExpirationAge time.Duration
        + MinRewriteToOrphanDeletionDelay time.Duration

    }
    class Schedule << (S,Aquamarine) >> {
        + NextFullMaintenanceTime time.Time
        + NextQuickMaintenanceTime time.Time
        + Runs <font color=blue>map</font>[TaskType][]RunInfo

        + ReportRun(taskType TaskType, info RunInfo) 

    }
    class contentInfoOrError << (S,Aquamarine) >> {
    }
    class maintenance.Mode << (T, #FF7700) >>  {
    }
    class maintenance.TaskType << (T, #FF7700) >>  {
    }
}
"content.Info" *-- "maintenance.contentInfoOrError"


namespace manifest {
    class EntryMetadata << (S,Aquamarine) >> {
        + ID ID
        + Length int
        + Labels <font color=blue>map</font>[string]string
        + ModTime time.Time

    }
    class Manager << (S,Aquamarine) >> {
        + Put(ctx context.Context, labels <font color=blue>map</font>[string]string, payload <font color=blue>interface</font>{}) (ID, error)
        + GetMetadata(ctx context.Context, id ID) (*EntryMetadata, error)
        + Get(ctx context.Context, id ID, data <font color=blue>interface</font>{}) (*EntryMetadata, error)
        + Find(ctx context.Context, labels <font color=blue>map</font>[string]string) ([]*EntryMetadata, error)
        + Flush(ctx context.Context) error
        + Delete(ctx context.Context, id ID) error
        + Compact(ctx context.Context) error

    }
    class ManagerOptions << (S,Aquamarine) >> {
        + TimeNow <font color=blue>func</font>() time.Time

    }
    class committedManifestManager << (S,Aquamarine) >> {
    }
    interface contentManager  {
        + Revision() int64
        + GetContent(ctx context.Context, contentID content.ID) ([]byte, error)
        + WriteContent(ctx context.Context, data gather.Bytes, prefix content.IDPrefix, comp compression.HeaderID) (content.ID, error)
        + DeleteContent(ctx context.Context, contentID content.ID) error
        + IterateContents(ctx context.Context, options content.IterateOptions, callback content.IterateCallback) error
        + DisableIndexFlush(ctx context.Context) 
        + EnableIndexFlush(ctx context.Context) 
        + Flush(ctx context.Context) error

    }
    class manifest << (S,Aquamarine) >> {
        + Entries []*manifestEntry

    }
    class manifest.ID << (T, #FF7700) >>  {
    }
    class manifestEntry << (S,Aquamarine) >> {
        + ID ID
        + Labels <font color=blue>map</font>[string]string
        + ModTime time.Time
        + Deleted bool
        + Content json.RawMessage

    }
}


namespace metricid {
    class Mapping << (S,Aquamarine) >> {
        + MaxIndex int
        + NameToIndex <font color=blue>map</font>[string]int
        + IndexToName <font color=blue>map</font>[int]string

    }
}


namespace metrics {
    class _metrics << (S,Aquamarine) >> {
        + Mean() T
        + Observe(value T) 
        + Snapshot(reset bool) *

    }
    class Counter << (S,Aquamarine) >> {
        + Add(v int64) 
        + Snapshot(reset bool) int64

    }
    class Distribution << (S,Aquamarine) >> {
    }
    class DistributionState << (S,Aquamarine) >> {
        + Min T
        + Max T
        + Sum T
        + Count int64
        + BucketCounters []int64
        + BucketThresholds []T

    }
    class Registry << (S,Aquamarine) >> {
        + CounterInt64(name string, help string, labels <font color=blue>map</font>[string]string) *Counter
        + DurationDistribution(name string, help string, thresholds *, labels <font color=blue>map</font>[string]string) *
        + SizeDistribution(name string, help string, thresholds *, labels <font color=blue>map</font>[string]string) *
        + Snapshot(reset bool) Snapshot
        + Close(ctx context.Context) error
        + Log(ctx context.Context) 
        + Throughput(name string, help string, labels <font color=blue>map</font>[string]string) *Throughput

    }
    class Snapshot << (S,Aquamarine) >> {
        + Counters <font color=blue>map</font>[string]int64
        + DurationDistributions <font color=blue>map</font>[string]*
        + SizeDistributions <font color=blue>map</font>[string]*

    }
    class Thresholds << (S,Aquamarine) >> {
    }
    class Throughput << (S,Aquamarine) >> {
        + Observe(size int64, dt time.Duration) 

    }
}


namespace mockfs {
    class Directory << (S,Aquamarine) >> {
        + AddFileLines(name string, lines []string, permissions os.FileMode) *File
        + AddFile(name string, content []byte, permissions os.FileMode) *File
        + AddFileWithSource(name string, permissions os.FileMode, source <font color=blue>func</font>() (ReaderSeekerCloser, error)) *File
        + AddSymlink(name string, target string, permissions os.FileMode) *Symlink
        + AddFileDevice(name string, content []byte, permissions os.FileMode, deviceInfo fs.DeviceInfo) *File
        + AddDir(name string, permissions os.FileMode) *Directory
        + AddErrorEntry(name string, permissions os.FileMode, err error) *ErrorEntry
        + AddDirDevice(name string, permissions os.FileMode, deviceInfo fs.DeviceInfo) *Directory
        + Subdir(name ...string) *Directory
        + Remove(name string) 
        + FailReaddir(err error) 
        + OnReaddir(cb <font color=blue>func</font>() ) 
        + SupportsMultipleIterations() bool
        + Child(ctx context.Context, name string) (fs.Entry, error)
        + IterateEntries(ctx context.Context, cb <font color=blue>func</font>(context.Context, fs.Entry) error) error

    }
    class ErrorEntry << (S,Aquamarine) >> {
        + ErrorInfo() error

    }
    class File << (S,Aquamarine) >> {
        + SetContents(b []byte) 
        + Open(ctx context.Context) (fs.Reader, error)

    }
    interface ReaderSeekerCloser  {
    }
    class Symlink << (S,Aquamarine) >> {
        + Readlink(ctx context.Context) (string, error)

    }
    class entry << (S,Aquamarine) >> {
        + Name() string
        + IsDir() bool
        + Mode() os.FileMode
        + ModTime() time.Time
        + Size() int64
        + Sys() <font color=blue>interface</font>{}
        + Owner() fs.OwnerInfo
        + Device() fs.DeviceInfo
        + LocalFilesystemPath() string
        + Close() 

    }
    class fileReader << (S,Aquamarine) >> {
        + Entry() (fs.Entry, error)

    }
    class readerSeekerCloser << (S,Aquamarine) >> {
        + Close() error

    }
}
"mockfs.entry" *-- "mockfs.Directory"
"mockfs.entry" *-- "mockfs.ErrorEntry"
"mockfs.entry" *-- "mockfs.File"
"mockfs.entry" *-- "mockfs.Symlink"
"mockfs.ReaderSeekerCloser" *-- "mockfs.fileReader"
"io.ReadSeeker" *-- "mockfs.readerSeekerCloser"

"fs.ErrorEntry" <|-- "mockfs.ErrorEntry"
"fs.File" <|-- "mockfs.File"
"fs.Symlink" <|-- "mockfs.Symlink"
"fs.Entry" <|-- "mockfs.entry"
"fs.Reader" <|-- "mockfs.fileReader"

namespace mount {
    interface Controller  {
        + Unmount(ctx context.Context) error
        + MountPath() string
        + Done() <font color=blue>chan</font> <font color=blue>struct</font>{}

    }
    class Options << (S,Aquamarine) >> {
        + FuseAllowOther bool
        + FuseAllowNonEmptyMount bool
        + PreferWebDAV bool

    }
    class fuseController << (S,Aquamarine) >> {
        + MountPath() string
        + Unmount(ctx context.Context) error
        + Done() <font color=blue>chan</font> <font color=blue>struct</font>{}

    }
    class netuseController << (S,Aquamarine) >> {
        + Unmount(ctx context.Context) error
        + MountPath() string
        + Done() <font color=blue>chan</font> <font color=blue>struct</font>{}

    }
    class posixWedavController << (S,Aquamarine) >> {
        + Unmount(ctx context.Context) error
        + MountPath() string
        + Done() <font color=blue>chan</font> <font color=blue>struct</font>{}

    }
    class webdavController << (S,Aquamarine) >> {
        + Unmount(ctx context.Context) error
        + MountPath() string
        + Done() <font color=blue>chan</font> <font color=blue>struct</font>{}

    }
}

"mount.Controller" <|-- "mount.fuseController"
"mount.Controller" <|-- "mount.netuseController"
"mount.Controller" <|-- "mount.posixWedavController"
"mount.Controller" <|-- "mount.webdavController"

namespace object {
    interface HasObjectID  {
        + ObjectID() ID

    }
    class ID << (S,Aquamarine) >> {
        + MarshalJSON() ([]byte, error)
        + UnmarshalJSON(v []byte) error
        + String() string
        + Append(out []byte) []byte
        + IndexObjectID() (ID, bool)
        + ContentID() (content.ID, bool, bool)

    }
    class IndirectObjectEntry << (S,Aquamarine) >> {
        + Start int64
        + Length int64
        + Object ID

    }
    class Manager << (S,Aquamarine) >> {
        + Format format.ObjectFormat

        + NewWriter(ctx context.Context, opt WriterOptions) Writer
        + Concatenate(ctx context.Context, objectIDs []ID) (ID, error)

    }
    interface Reader  {
        + Length() int64

    }
    interface Writer  {
        + Checkpoint() (ID, error)
        + Result() (ID, error)

    }
    class WriterOptions << (S,Aquamarine) >> {
        + Description string
        + Prefix content.IDPrefix
        + Compressor compression.Name
        + AsyncWrites int

    }
    class contentIDTracker << (S,Aquamarine) >> {
    }
    interface contentManager  {
        + SupportsContentCompression() (bool, error)
        + WriteContent(ctx context.Context, data gather.Bytes, prefix content.IDPrefix, comp compression.HeaderID) (content.ID, error)

    }
    interface contentReader  {
        + ContentInfo(ctx context.Context, contentID content.ID) (content.Info, error)
        + GetContent(ctx context.Context, contentID content.ID) ([]byte, error)
        + PrefetchContents(ctx context.Context, contentIDs []content.ID, prefetchHint string) []content.ID

    }
    class indirectObject << (S,Aquamarine) >> {
        + StreamID string
        + Entries []IndirectObjectEntry

    }
    class objectReader << (S,Aquamarine) >> {
        + Read(buffer []byte) (int, error)
        + Seek(offset int64, whence int) (int64, error)
        + Close() error
        + Length() int64

    }
    class objectWriter << (S,Aquamarine) >> {
        + Close() error
        + Write(data []byte) (int, error)
        + Result() (ID, error)
        + Checkpoint() (ID, error)

    }
    class readerWithData << (S,Aquamarine) >> {
        + Close() error
        + Length() int64

    }
}
"object.contentReader" *-- "object.contentManager"
"io.ReadSeeker" *-- "object.readerWithData"

"object.Reader" <|-- "object.objectReader"
"object.Writer" <|-- "object.objectWriter"
"object.Reader" <|-- "object.readerWithData"

namespace ownwrites {
    class CacheStorage << (S,Aquamarine) >> {
        + ListBlobs(ctx context.Context, prefix blob.ID, cb <font color=blue>func</font>(blob.Metadata) error) error
        + PutBlob(ctx context.Context, blobID blob.ID, data blob.Bytes, opts blob.PutOptions) error
        + DeleteBlob(ctx context.Context, blobID blob.ID) error

    }
}
"blob.Storage" *-- "ownwrites.CacheStorage"


namespace parallelwork {
    class Queue << (S,Aquamarine) >> {
        + ProgressCallback <font color=blue>func</font>(context.Context, int64, int64, int64) 

        + EnqueueFront(ctx context.Context, callback CallbackFunc) 
        + EnqueueBack(ctx context.Context, callback CallbackFunc) 
        + Process(ctx context.Context, workers int) error

    }
    class parallelwork.CallbackFunc << (T, #FF7700) >>  {
    }
}


namespace passwordpersist {
    class Multiple << (S,Aquamarine) >> {
        + GetPassword(ctx context.Context, configFile string) (string, error)
        + PersistPassword(ctx context.Context, configFile string, password string) error
        + DeletePassword(ctx context.Context, configFile string) error

    }
    interface Strategy  {
        + GetPassword(ctx context.Context, configFile string) (string, error)
        + PersistPassword(ctx context.Context, configFile string, password string) error
        + DeletePassword(ctx context.Context, configFile string) error

    }
    class filePasswordStorage << (S,Aquamarine) >> {
        + GetPassword(ctx context.Context, configFile string) (string, error)
        + PersistPassword(ctx context.Context, configFile string, password string) error
        + DeletePassword(ctx context.Context, configFile string) error

    }
    class keyringStrategy << (S,Aquamarine) >> {
        + GetPassword(ctx context.Context, configFile string) (string, error)
        + PersistPassword(ctx context.Context, configFile string, password string) error
        + DeletePassword(ctx context.Context, configFile string) error

    }
    class noneStrategy << (S,Aquamarine) >> {
        + GetPassword(ctx context.Context, configFile string) (string, error)
        + PersistPassword(ctx context.Context, configFile string, password string) error
        + DeletePassword(ctx context.Context, configFile string) error

    }
    class passwordpersist.Multiple << (T, #FF7700) >>  {
    }
}

"passwordpersist.Strategy" <|-- "passwordpersist.Multiple"
"passwordpersist.Strategy" <|-- "passwordpersist.filePasswordStorage"
"passwordpersist.Strategy" <|-- "passwordpersist.keyringStrategy"
"passwordpersist.Strategy" <|-- "passwordpersist.noneStrategy"

namespace policy {
    class ActionCommand << (S,Aquamarine) >> {
        + Command string
        + Arguments []string
        + Script string
        + TimeoutSeconds int
        + Mode string

    }
    class ActionsPolicy << (S,Aquamarine) >> {
        + BeforeFolder *ActionCommand
        + AfterFolder *ActionCommand
        + BeforeSnapshotRoot *ActionCommand
        + AfterSnapshotRoot *ActionCommand

        + Merge(src ActionsPolicy, def *ActionsPolicyDefinition, si snapshot.SourceInfo) 
        + MergeNonInheritable(src ActionsPolicy) 

    }
    class ActionsPolicyDefinition << (S,Aquamarine) >> {
        + BeforeSnapshotRoot snapshot.SourceInfo
        + AfterSnapshotRoot snapshot.SourceInfo

    }
    class CompressionPolicy << (S,Aquamarine) >> {
        + CompressorName compression.Name
        + OnlyCompress []string
        + NoParentOnlyCompress bool
        + NeverCompress []string
        + NoParentNeverCompress bool
        + MinSize int64
        + MaxSize int64

        + CompressorForFile(e fs.Entry) compression.Name
        + Merge(src CompressionPolicy, def *CompressionPolicyDefinition, si snapshot.SourceInfo) 

    }
    class CompressionPolicyDefinition << (S,Aquamarine) >> {
        + CompressorName snapshot.SourceInfo
        + OnlyCompress snapshot.SourceInfo
        + NeverCompress snapshot.SourceInfo
        + MinSize snapshot.SourceInfo
        + MaxSize snapshot.SourceInfo

    }
    class Definition << (S,Aquamarine) >> {
        + RetentionPolicy RetentionPolicyDefinition
        + FilesPolicy FilesPolicyDefinition
        + ErrorHandlingPolicy ErrorHandlingPolicyDefinition
        + SchedulingPolicy SchedulingPolicyDefinition
        + CompressionPolicy CompressionPolicyDefinition
        + Actions ActionsPolicyDefinition
        + LoggingPolicy LoggingPolicyDefinition
        + UploadPolicy UploadPolicyDefinition

    }
    class DirLoggingPolicy << (S,Aquamarine) >> {
        + Snapshotted *LogDetail
        + Ignored *LogDetail

        + Merge(src DirLoggingPolicy, def *DirLoggingPolicyDefinition, si snapshot.SourceInfo) 

    }
    class DirLoggingPolicyDefinition << (S,Aquamarine) >> {
        + Snapshotted snapshot.SourceInfo
        + Ignored snapshot.SourceInfo

    }
    class EntryLoggingPolicy << (S,Aquamarine) >> {
        + Snapshotted *LogDetail
        + Ignored *LogDetail
        + CacheHit *LogDetail
        + CacheMiss *LogDetail

        + Merge(src EntryLoggingPolicy, def *EntryLoggingPolicyDefinition, si snapshot.SourceInfo) 

    }
    class EntryLoggingPolicyDefinition << (S,Aquamarine) >> {
        + Snapshotted snapshot.SourceInfo
        + Ignored snapshot.SourceInfo
        + CacheHit snapshot.SourceInfo
        + CacheMiss snapshot.SourceInfo

    }
    class ErrorHandlingPolicy << (S,Aquamarine) >> {
        + IgnoreFileErrors *OptionalBool
        + IgnoreDirectoryErrors *OptionalBool
        + IgnoreUnknownTypes *OptionalBool

        + Merge(src ErrorHandlingPolicy, def *ErrorHandlingPolicyDefinition, si snapshot.SourceInfo) 

    }
    class ErrorHandlingPolicyDefinition << (S,Aquamarine) >> {
        + IgnoreFileErrors snapshot.SourceInfo
        + IgnoreDirectoryErrors snapshot.SourceInfo
        + IgnoreUnknownTypes snapshot.SourceInfo

    }
    class FilesPolicy << (S,Aquamarine) >> {
        + IgnoreRules []string
        + NoParentIgnoreRules bool
        + DotIgnoreFiles []string
        + NoParentDotIgnoreFiles bool
        + IgnoreCacheDirectories *OptionalBool
        + MaxFileSize int64
        + OneFileSystem *OptionalBool

        + Merge(src FilesPolicy, def *FilesPolicyDefinition, si snapshot.SourceInfo) 

    }
    class FilesPolicyDefinition << (S,Aquamarine) >> {
        + IgnoreRules snapshot.SourceInfo
        + NoParentIgnoreRules snapshot.SourceInfo
        + DotIgnoreFiles snapshot.SourceInfo
        + NoParentDotIgnoreFiles snapshot.SourceInfo
        + IgnoreCacheDirectories snapshot.SourceInfo
        + MaxFileSize snapshot.SourceInfo
        + OneFileSystem snapshot.SourceInfo

    }
    class LogDetail << (S,Aquamarine) >> {
        + OrDefault(def LogDetail) LogDetail

    }
    class LoggingPolicy << (S,Aquamarine) >> {
        + Directories DirLoggingPolicy
        + Entries EntryLoggingPolicy

        + Merge(src LoggingPolicy, def *LoggingPolicyDefinition, si snapshot.SourceInfo) 

    }
    class LoggingPolicyDefinition << (S,Aquamarine) >> {
        + Directories DirLoggingPolicyDefinition
        + Entries EntryLoggingPolicyDefinition

    }
    class OptionalBool << (S,Aquamarine) >> {
        + OrDefault(def bool) bool

    }
    class OptionalInt << (S,Aquamarine) >> {
        + OrDefault(def int) int

    }
    class OptionalInt64 << (S,Aquamarine) >> {
        + OrDefault(def int64) int64

    }
    class Policy << (S,Aquamarine) >> {
        + Labels <font color=blue>map</font>[string]string
        + RetentionPolicy RetentionPolicy
        + FilesPolicy FilesPolicy
        + ErrorHandlingPolicy ErrorHandlingPolicy
        + SchedulingPolicy SchedulingPolicy
        + CompressionPolicy CompressionPolicy
        + Actions ActionsPolicy
        + LoggingPolicy LoggingPolicy
        + UploadPolicy UploadPolicy
        + NoParent bool

        + String() string
        + ID() string
        + Target() snapshot.SourceInfo

    }
    class RetentionPolicy << (S,Aquamarine) >> {
        + KeepLatest *OptionalInt
        + KeepHourly *OptionalInt
        + KeepDaily *OptionalInt
        + KeepWeekly *OptionalInt
        + KeepMonthly *OptionalInt
        + KeepAnnual *OptionalInt
        + IgnoreIdenticalSnapshots *OptionalBool

        + ComputeRetentionReasons(manifests []*snapshot.Manifest) 
        + EffectiveKeepLatest() *OptionalInt
        + Merge(src RetentionPolicy, def *RetentionPolicyDefinition, si snapshot.SourceInfo) 

    }
    class RetentionPolicyDefinition << (S,Aquamarine) >> {
        + KeepLatest snapshot.SourceInfo
        + KeepHourly snapshot.SourceInfo
        + KeepDaily snapshot.SourceInfo
        + KeepWeekly snapshot.SourceInfo
        + KeepMonthly snapshot.SourceInfo
        + KeepAnnual snapshot.SourceInfo
        + IgnoreIdenticalSnapshots snapshot.SourceInfo

    }
    class SchedulingPolicy << (S,Aquamarine) >> {
        + IntervalSeconds int64
        + TimesOfDay []TimeOfDay
        + NoParentTimesOfDay bool
        + Manual bool

        + Interval() time.Duration
        + SetInterval(d time.Duration) 
        + NextSnapshotTime(previousSnapshotTime time.Time, now time.Time) (time.Time, bool)
        + Merge(src SchedulingPolicy, def *SchedulingPolicyDefinition, si snapshot.SourceInfo) 

    }
    class SchedulingPolicyDefinition << (S,Aquamarine) >> {
        + IntervalSeconds snapshot.SourceInfo
        + TimesOfDay snapshot.SourceInfo
        + Manual snapshot.SourceInfo

    }
    class SubdirectoryPolicyMap << (S,Aquamarine) >> {
        + GetPolicyForPath(relativePath string) (*Policy, error)

    }
    class TargetWithPolicy << (S,Aquamarine) >> {
        + ID string
        + Target snapshot.SourceInfo

    }
    class TimeOfDay << (S,Aquamarine) >> {
        + Hour int
        + Minute int

        + Parse(s string) error
        + String() string

    }
    class Tree << (S,Aquamarine) >> {
        + DefinedPolicy() *Policy
        + EffectivePolicy() *Policy
        + IsInherited() bool
        + Child(name string) *Tree

    }
    class UploadPolicy << (S,Aquamarine) >> {
        + MaxParallelSnapshots *OptionalInt
        + MaxParallelFileReads *OptionalInt
        + ParallelUploadAboveSize *OptionalInt64

        + Merge(src UploadPolicy, def *UploadPolicyDefinition, si snapshot.SourceInfo) 

    }
    class UploadPolicyDefinition << (S,Aquamarine) >> {
        + MaxParallelSnapshots snapshot.SourceInfo
        + MaxParallelFileReads snapshot.SourceInfo
        + ParallelUploadAboveSize snapshot.SourceInfo

    }
    class cutoffTimes << (S,Aquamarine) >> {
    }
    class policy.LogDetail << (T, #FF7700) >>  {
    }
    class policy.OptionalBool << (T, #FF7700) >>  {
    }
    class policy.OptionalInt << (T, #FF7700) >>  {
    }
    class policy.OptionalInt64 << (T, #FF7700) >>  {
    }
    class policy.SubdirectoryPolicyMap << (T, #FF7700) >>  {
    }
}
"policy.Policy" *-- "policy.TargetWithPolicy"


namespace providervalidation {
    class Options << (S,Aquamarine) >> {
        + MaxClockDrift time.Duration
        + ConcurrencyTestDuration time.Duration
        + NumPutBlobWorkers int
        + NumGetBlobWorkers int
        + NumGetMetadataWorkers int
        + NumListBlobsWorkers int
        + MaxBlobLength int

    }
    class concurrencyTest << (S,Aquamarine) >> {
    }
}


namespace rclone {
    class Options << (S,Aquamarine) >> {
        + RemotePath string
        + RCloneExe string
        + RCloneArgs []string
        + RCloneEnv []string
        + StartupTimeout int
        + Debug bool
        + NoWaitForTransfers bool
        + EmbeddedConfig string
        + AtomicWrites bool

    }
    class rcloneStorage << (S,Aquamarine) >> {
        + PutBlob(ctx context.Context, b blob.ID, data blob.Bytes, opts blob.PutOptions) error
        + ConnectionInfo() blob.ConnectionInfo
        + Kill() 
        + Close(ctx context.Context) error
        + DisplayName() string

    }
}
"sharded.Options" *-- "rclone.Options"
"throttling.Limits" *-- "rclone.Options"
"blob.Storage" *-- "rclone.rcloneStorage"
"rclone.Options" *-- "rclone.rcloneStorage"


namespace readonly {
    class readonlyStorage << (S,Aquamarine) >> {
        + GetCapacity(ctx context.Context) (blob.Capacity, error)
        + GetBlob(ctx context.Context, id blob.ID, offset int64, length int64, output blob.OutputBuffer) error
        + GetMetadata(ctx context.Context, id blob.ID) (blob.Metadata, error)
        + PutBlob(ctx context.Context, id blob.ID, data blob.Bytes, opts blob.PutOptions) error
        + DeleteBlob(ctx context.Context, id blob.ID) error
        + ListBlobs(ctx context.Context, prefix blob.ID, callback <font color=blue>func</font>(blob.Metadata) error) error
        + Close(ctx context.Context) error
        + ConnectionInfo() blob.ConnectionInfo
        + DisplayName() string
        + FlushCaches(ctx context.Context) error

    }
}

"blob.Storage" <|-- "readonly.readonlyStorage"
"blob.Volume" <|-- "readonly.readonlyStorage"

namespace releasable {
    class perKindTracker << (S,Aquamarine) >> {
    }
    class releasable.ItemKind << (T, #FF7700) >>  {
    }
}


namespace remoterepoapi {
    class ManifestWithMetadata << (S,Aquamarine) >> {
        + Payload json.RawMessage
        + Metadata *manifest.EntryMetadata

    }
    class Parameters << (S,Aquamarine) >> {
        + HashFunction string
        + HMACSecret []byte
        + SupportsContentCompression bool

        + GetHashFunction() string
        + GetHmacSecret() []byte

    }
    class PrefetchContentsRequest << (S,Aquamarine) >> {
        + ContentIDs []content.ID
        + Hint string

    }
    class PrefetchContentsResponse << (S,Aquamarine) >> {
        + ContentIDs []content.ID

    }
}
"format.ObjectFormat" *-- "remoterepoapi.Parameters"

"hashing.Parameters" <|-- "remoterepoapi.Parameters"

namespace repo {
    class APIServerInfo << (S,Aquamarine) >> {
        + BaseURL string
        + TrustedServerCertificateFingerprint string
        + DisableGRPC bool

    }
    class ClientOptions << (S,Aquamarine) >> {
        + Hostname string
        + Username string
        + ReadOnly bool
        + PermissiveCacheLoading bool
        + Description string
        + EnableActions bool
        + FormatBlobCacheDuration time.Duration
        + Throttling *throttling.Limits

        + ApplyDefaults(ctx context.Context, defaultDesc string) ClientOptions
        + Override(other ClientOptions) ClientOptions
        + UsernameAtHost() string

    }
    class ConnectOptions << (S,Aquamarine) >> {
    }
    interface DirectRepository  {
        + ObjectFormat() format.ObjectFormat
        + FormatManager() *format.Manager
        + BlobReader() blob.Reader
        + BlobVolume() blob.Volume
        + ContentReader() content.Reader
        + IndexBlobs(ctx context.Context, includeInactive bool) ([]indexblob.Metadata, error)
        + NewDirectWriter(ctx context.Context, opt WriteSessionOptions) (context.Context, DirectRepositoryWriter, error)
        + AlsoLogToContentLog(ctx context.Context) context.Context
        + UniqueID() []byte
        + ConfigFilename() string
        + DeriveKey(purpose []byte, keyLength int) []byte
        + Token(password string) (string, error)
        + Throttler() throttling.SettableThrottler
        + DisableIndexRefresh() 

    }
    interface DirectRepositoryWriter  {
        + BlobStorage() blob.Storage
        + ContentManager() *content.WriteManager

    }
    class LocalConfig << (S,Aquamarine) >> {
        + APIServer *APIServerInfo
        + Storage *blob.ConnectionInfo
        + Caching *content.CachingOptions

    }
    class NewRepositoryOptions << (S,Aquamarine) >> {
        + UniqueID []byte
        + BlockFormat format.ContentFormat
        + DisableHMAC bool
        + ObjectFormat format.ObjectFormat
        + RetentionMode blob.RetentionMode
        + RetentionPeriod time.Duration

    }
    class Options << (S,Aquamarine) >> {
        + TraceStorage bool
        + TimeNowFunc <font color=blue>func</font>() time.Time
        + DisableInternalLog bool
        + UpgradeOwnerID string
        + DoNotWaitForUpgrade bool
        + BeforeFlush []RepositoryWriterCallback
        + OnFatalError <font color=blue>func</font>(error) 
        + TestOnlyIgnoreMissingRequiredFeatures bool

    }
    interface Repository  {
        + OpenObject(ctx context.Context, id object.ID) (object.Reader, error)
        + VerifyObject(ctx context.Context, id object.ID) ([]content.ID, error)
        + GetManifest(ctx context.Context, id manifest.ID, data <font color=blue>interface</font>{}) (*manifest.EntryMetadata, error)
        + FindManifests(ctx context.Context, labels <font color=blue>map</font>[string]string) ([]*manifest.EntryMetadata, error)
        + ContentInfo(ctx context.Context, contentID content.ID) (content.Info, error)
        + PrefetchContents(ctx context.Context, contentIDs []content.ID, hint string) []content.ID
        + PrefetchObjects(ctx context.Context, objectIDs []object.ID, hint string) ([]content.ID, error)
        + Time() time.Time
        + ClientOptions() ClientOptions
        + NewWriter(ctx context.Context, opt WriteSessionOptions) (context.Context, RepositoryWriter, error)
        + UpdateDescription(d string) 
        + Refresh(ctx context.Context) error
        + Close(ctx context.Context) error

    }
    interface RepositoryWriter  {
        + NewObjectWriter(ctx context.Context, opt object.WriterOptions) object.Writer
        + ConcatenateObjects(ctx context.Context, objectIDs []object.ID) (object.ID, error)
        + PutManifest(ctx context.Context, labels <font color=blue>map</font>[string]string, payload <font color=blue>interface</font>{}) (manifest.ID, error)
        + ReplaceManifests(ctx context.Context, labels <font color=blue>map</font>[string]string, payload <font color=blue>interface</font>{}) (manifest.ID, error)
        + DeleteManifest(ctx context.Context, id manifest.ID) error
        + OnSuccessfulFlush(callback RepositoryWriterCallback) 
        + Flush(ctx context.Context) error

    }
    class WriteSessionOptions << (S,Aquamarine) >> {
        + Purpose string
        + FlushOnFailure bool
        + OnUpload <font color=blue>func</font>(int64) 

    }
    class apiServerRepository << (S,Aquamarine) >> {
        + APIServerURL() string
        + Description() string
        + OpenObject(ctx context.Context, id object.ID) (object.Reader, error)
        + NewObjectWriter(ctx context.Context, opt object.WriterOptions) object.Writer
        + ConcatenateObjects(ctx context.Context, objectIDs []object.ID) (object.ID, error)
        + VerifyObject(ctx context.Context, id object.ID) ([]content.ID, error)
        + GetManifest(ctx context.Context, id manifest.ID, data <font color=blue>interface</font>{}) (*manifest.EntryMetadata, error)
        + PutManifest(ctx context.Context, labels <font color=blue>map</font>[string]string, payload <font color=blue>interface</font>{}) (manifest.ID, error)
        + ReplaceManifests(ctx context.Context, labels <font color=blue>map</font>[string]string, payload <font color=blue>interface</font>{}) (manifest.ID, error)
        + SetFindManifestPageSizeForTesting(v int32) 
        + FindManifests(ctx context.Context, labels <font color=blue>map</font>[string]string) ([]*manifest.EntryMetadata, error)
        + DeleteManifest(ctx context.Context, id manifest.ID) error
        + Time() time.Time
        + Refresh(ctx context.Context) error
        + Flush(ctx context.Context) error
        + SupportsContentCompression() (bool, error)
        + NewWriter(ctx context.Context, opt WriteSessionOptions) (context.Context, RepositoryWriter, error)
        + ContentInfo(ctx context.Context, contentID content.ID) (content.Info, error)
        + GetContent(ctx context.Context, contentID content.ID) ([]byte, error)
        + WriteContent(ctx context.Context, data gather.Bytes, prefix content.IDPrefix, comp compression.HeaderID) (content.ID, error)
        + UpdateDescription(d string) 
        + PrefetchObjects(ctx context.Context, objectIDs []object.ID, hint string) ([]content.ID, error)
        + PrefetchContents(ctx context.Context, contentIDs []content.ID, hint string) []content.ID
        + OnSuccessfulFlush(callback RepositoryWriterCallback) 

    }
    class directRepository << (S,Aquamarine) >> {
        + DeriveKey(purpose []byte, keyLength int) []byte
        + ClientOptions() ClientOptions
        + BlobStorage() blob.Storage
        + Throttler() throttling.SettableThrottler
        + ContentManager() *content.WriteManager
        + ConfigFilename() string
        + NewObjectWriter(ctx context.Context, opt object.WriterOptions) object.Writer
        + ConcatenateObjects(ctx context.Context, objectIDs []object.ID) (object.ID, error)
        + DisableIndexRefresh() 
        + OpenObject(ctx context.Context, id object.ID) (object.Reader, error)
        + VerifyObject(ctx context.Context, id object.ID) ([]content.ID, error)
        + GetManifest(ctx context.Context, id manifest.ID, data <font color=blue>interface</font>{}) (*manifest.EntryMetadata, error)
        + PutManifest(ctx context.Context, labels <font color=blue>map</font>[string]string, payload <font color=blue>interface</font>{}) (manifest.ID, error)
        + ReplaceManifests(ctx context.Context, labels <font color=blue>map</font>[string]string, payload <font color=blue>interface</font>{}) (manifest.ID, error)
        + FindManifests(ctx context.Context, labels <font color=blue>map</font>[string]string) ([]*manifest.EntryMetadata, error)
        + DeleteManifest(ctx context.Context, id manifest.ID) error
        + PrefetchContents(ctx context.Context, contentIDs []content.ID, hint string) []content.ID
        + PrefetchObjects(ctx context.Context, objectIDs []object.ID, hint string) ([]content.ID, error)
        + ListActiveSessions(ctx context.Context) (<font color=blue>map</font>[content.SessionID]*content.SessionInfo, error)
        + ContentInfo(ctx context.Context, contentID content.ID) (content.Info, error)
        + UpdateDescription(d string) 
        + AlsoLogToContentLog(ctx context.Context) context.Context
        + NewWriter(ctx context.Context, opt WriteSessionOptions) (context.Context, RepositoryWriter, error)
        + NewDirectWriter(ctx context.Context, opt WriteSessionOptions) (context.Context, DirectRepositoryWriter, error)
        + Flush(ctx context.Context) error
        + Metrics() *metrics.Registry
        + ObjectFormat() format.ObjectFormat
        + UniqueID() []byte
        + BlobReader() blob.Reader
        + BlobVolume() blob.Volume
        + ContentReader() content.Reader
        + IndexBlobs(ctx context.Context, includeInactive bool) ([]indexblob.Metadata, error)
        + Refresh(ctx context.Context) error
        + Time() time.Time
        + FormatManager() *format.Manager
        + OnSuccessfulFlush(callback RepositoryWriterCallback) 
        + Token(password string) (string, error)

    }
    class grpcCreds << (S,Aquamarine) >> {
        + GetRequestMetadata(ctx context.Context, uri ...string) (<font color=blue>map</font>[string]string, error)
        + RequireTransportSecurity() bool

    }
    class grpcInnerSession << (S,Aquamarine) >> {
        + GetManifest(ctx context.Context, id manifest.ID, data <font color=blue>interface</font>{}) (*manifest.EntryMetadata, error)
        + PutManifest(ctx context.Context, labels <font color=blue>map</font>[string]string, payload <font color=blue>interface</font>{}) (manifest.ID, error)
        + FindManifests(ctx context.Context, labels <font color=blue>map</font>[string]string, pageSize int32) ([]*manifest.EntryMetadata, error)
        + DeleteManifest(ctx context.Context, id manifest.ID) error
        + PrefetchContents(ctx context.Context, contentIDs []content.ID, hint string) []content.ID
        + Flush(ctx context.Context) error
        + GetContent(ctx context.Context, contentID content.ID) ([]byte, error)
        + WriteContentAsyncAndVerify(ctx context.Context, contentID content.ID, data []byte, prefix content.IDPrefix, comp compression.HeaderID, eg *errgroup.Group) 

    }
    class grpcRepositoryClient << (S,Aquamarine) >> {
        + Description() string
        + LegacyWriter() RepositoryWriter
        + OpenObject(ctx context.Context, id object.ID) (object.Reader, error)
        + NewObjectWriter(ctx context.Context, opt object.WriterOptions) object.Writer
        + VerifyObject(ctx context.Context, id object.ID) ([]content.ID, error)
        + GetManifest(ctx context.Context, id manifest.ID, data <font color=blue>interface</font>{}) (*manifest.EntryMetadata, error)
        + PutManifest(ctx context.Context, labels <font color=blue>map</font>[string]string, payload <font color=blue>interface</font>{}) (manifest.ID, error)
        + ReplaceManifests(ctx context.Context, labels <font color=blue>map</font>[string]string, payload <font color=blue>interface</font>{}) (manifest.ID, error)
        + SetFindManifestPageSizeForTesting(v int32) 
        + FindManifests(ctx context.Context, labels <font color=blue>map</font>[string]string) ([]*manifest.EntryMetadata, error)
        + DeleteManifest(ctx context.Context, id manifest.ID) error
        + PrefetchObjects(ctx context.Context, objectIDs []object.ID, hint string) ([]content.ID, error)
        + PrefetchContents(ctx context.Context, contentIDs []content.ID, hint string) []content.ID
        + Time() time.Time
        + Refresh(ctx context.Context) error
        + Flush(ctx context.Context) error
        + NewWriter(ctx context.Context, opt WriteSessionOptions) (context.Context, RepositoryWriter, error)
        + ConcatenateObjects(ctx context.Context, objectIDs []object.ID) (object.ID, error)
        + ContentInfo(ctx context.Context, contentID content.ID) (content.Info, error)
        + GetContent(ctx context.Context, contentID content.ID) ([]byte, error)
        + SupportsContentCompression() (bool, error)
        + WriteContent(ctx context.Context, data gather.Bytes, prefix content.IDPrefix, comp compression.HeaderID) (content.ID, error)
        + UpdateDescription(d string) 
        + OnSuccessfulFlush(callback RepositoryWriterCallback) 

    }
    class immutableDirectRepositoryParameters << (S,Aquamarine) >> {
    }
    class immutableServerRepositoryParameters << (S,Aquamarine) >> {
        + Metrics() *metrics.Registry
        + ClientOptions() ClientOptions

    }
    class recentlyRead << (S,Aquamarine) >> {
    }
    class refCountedCloser << (S,Aquamarine) >> {
        + Close(ctx context.Context) error

    }
    class repo.RepositoryWriterCallback << (T, #FF7700) >>  {
    }
    class repo.closeFunc << (T, #FF7700) >>  {
    }
    class tokenInfo << (S,Aquamarine) >> {
        + Version string
        + Storage blob.ConnectionInfo
        + Password string

    }
    class "<font color=blue>func</font>(context.Context, RepositoryWriter) error" as fontcolorbluefuncfontcontextContextRepositoryWritererror {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "<font color=blue>func</font>(context.Context) error" as fontcolorbluefuncfontcontextContexterror {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
}
"content.CachingOptions" *-- "repo.ConnectOptions"
"repo.ClientOptions" *-- "repo.ConnectOptions"
"repo.Repository" *-- "repo.DirectRepository"
"repo.DirectRepository" *-- "repo.DirectRepositoryWriter"
"repo.RepositoryWriter" *-- "repo.DirectRepositoryWriter"
"repo.ClientOptions" *-- "repo.LocalConfig"
"repo.Repository" *-- "repo.RepositoryWriter"
"repo.immutableServerRepositoryParameters" *-- "repo.apiServerRepository"
"repo.immutableDirectRepositoryParameters" *-- "repo.directRepository"
"repo.immutableServerRepositoryParameters" *-- "repo.grpcRepositoryClient"
"repo.refCountedCloser" *-- "repo.immutableDirectRepositoryParameters"
"repo.refCountedCloser" *-- "repo.immutableServerRepositoryParameters"

"object.contentManager" <|-- "repo.apiServerRepository"
"object.contentReader" <|-- "repo.apiServerRepository"
"repo.RepositoryWriter" <|-- "repo.apiServerRepository"
"repo.DirectRepository" <|-- "repo.directRepository"
"repo.DirectRepositoryWriter" <|-- "repo.directRepository"
"repo.RepositoryWriter" <|-- "repo.directRepository"
"object.contentManager" <|-- "repo.grpcRepositoryClient"
"object.contentReader" <|-- "repo.grpcRepositoryClient"
"repo.RepositoryWriter" <|-- "repo.grpcRepositoryClient"

namespace repolog {
    class LogManager << (S,Aquamarine) >> {
        + Close(ctx context.Context) 
        + NewLogger() *zap.SugaredLogger
        + Enable() 

    }
    class internalLogger << (S,Aquamarine) >> {
        + Write(b []byte) (int, error)
        + Sync() error

    }
}


namespace repotesting {
    class Environment << (S,Aquamarine) >> {
        + Repository repo.Repository
        + RepositoryWriter repo.DirectRepositoryWriter
        + Password string

        + RepositoryMetrics() *metrics.Registry
        + RootStorage() blob.Storage
        + Close(ctx context.Context, tb testing.TB) 
        + ConfigFile() string
        + MustReopen(tb testing.TB, openOpts ...<font color=blue>func</font>(*repo.Options) ) 
        + MustOpenAnother(tb testing.TB, openOpts ...<font color=blue>func</font>(*repo.Options) ) repo.RepositoryWriter
        + MustConnectOpenAnother(tb testing.TB, openOpts ...<font color=blue>func</font>(*repo.Options) ) repo.Repository
        + VerifyBlobCount(tb testing.TB, want int) 
        + LocalPathSourceInfo(path string) snapshot.SourceInfo

    }
    class Options << (S,Aquamarine) >> {
        + NewRepositoryOptions <font color=blue>func</font>(*repo.NewRepositoryOptions) 
        + OpenOptions <font color=blue>func</font>(*repo.Options) 

    }
    class ReconnectableStorageOptions << (S,Aquamarine) >> {
        + UUID string

    }
    class reconnectableStorage << (S,Aquamarine) >> {
        + ConnectionInfo() blob.ConnectionInfo

    }
}
"blob.Storage" *-- "repotesting.reconnectableStorage"


namespace restore {
    class FilesystemOutput << (S,Aquamarine) >> {
        + TargetPath string
        + OverwriteDirectories bool
        + OverwriteFiles bool
        + OverwriteSymlinks bool
        + IgnorePermissionErrors bool
        + WriteFilesAtomically bool
        + SkipOwners bool
        + SkipPermissions bool
        + SkipTimes bool
        + WriteSparseFiles bool

        + Init(ctx context.Context) error
        + Parallelizable() bool
        + BeginDirectory(ctx context.Context, relativePath string, e fs.Directory) error
        + FinishDirectory(ctx context.Context, relativePath string, e fs.Directory) error
        + WriteDirEntry(ctx context.Context, relativePath string, de *snapshot.DirEntry, e fs.Directory) error
        + Close(ctx context.Context) error
        + WriteFile(ctx context.Context, relativePath string, f fs.File) error
        + FileExists(ctx context.Context, relativePath string, e fs.File) bool
        + CreateSymlink(ctx context.Context, relativePath string, e fs.Symlink) error
        + SymlinkExists(ctx context.Context, relativePath string, e fs.Symlink) bool

    }
    class Options << (S,Aquamarine) >> {
        + Parallel int
        + Incremental bool
        + IgnoreErrors bool
        + RestoreDirEntryAtDepth int32
        + MinSizeForPlaceholder int32
        + ProgressCallback <font color=blue>func</font>(context.Context, Stats) 
        + Cancel <font color=blue>chan</font> <font color=blue>struct</font>{}

    }
    interface Output  {
        + Parallelizable() bool
        + BeginDirectory(ctx context.Context, relativePath string, e fs.Directory) error
        + WriteDirEntry(ctx context.Context, relativePath string, de *snapshot.DirEntry, e fs.Directory) error
        + FinishDirectory(ctx context.Context, relativePath string, e fs.Directory) error
        + WriteFile(ctx context.Context, relativePath string, e fs.File) error
        + FileExists(ctx context.Context, relativePath string, e fs.File) bool
        + CreateSymlink(ctx context.Context, relativePath string, e fs.Symlink) error
        + SymlinkExists(ctx context.Context, relativePath string, e fs.Symlink) bool
        + Close(ctx context.Context) error

    }
    class ShallowFilesystemOutput << (S,Aquamarine) >> {
        + MinSizeForPlaceholder int32

        + WriteDirEntry(ctx context.Context, relativePath string, de *snapshot.DirEntry, e fs.Directory) error
        + WriteFile(ctx context.Context, relativePath string, f fs.File) error

    }
    class Stats << (S,Aquamarine) >> {
        + RestoredTotalFileSize int64
        + EnqueuedTotalFileSize int64
        + SkippedTotalFileSize int64
        + RestoredFileCount int32
        + RestoredDirCount int32
        + RestoredSymlinkCount int32
        + EnqueuedFileCount int32
        + EnqueuedDirCount int32
        + EnqueuedSymlinkCount int32
        + SkippedCount int32
        + IgnoredErrorCount int32

    }
    class TarOutput << (S,Aquamarine) >> {
        + Parallelizable() bool
        + BeginDirectory(ctx context.Context, relativePath string, d fs.Directory) error
        + FinishDirectory(ctx context.Context, relativePath string, e fs.Directory) error
        + WriteDirEntry(ctx context.Context, relativePath string, de *snapshot.DirEntry, e fs.Directory) error
        + Close(ctx context.Context) error
        + WriteFile(ctx context.Context, relativePath string, f fs.File) error
        + FileExists(ctx context.Context, relativePath string, f fs.File) bool
        + CreateSymlink(ctx context.Context, relativePath string, l fs.Symlink) error
        + SymlinkExists(ctx context.Context, relativePath string, l fs.Symlink) bool

    }
    class ZipOutput << (S,Aquamarine) >> {
        + Parallelizable() bool
        + BeginDirectory(ctx context.Context, relativePath string, e fs.Directory) error
        + FinishDirectory(ctx context.Context, relativePath string, e fs.Directory) error
        + WriteDirEntry(ctx context.Context, relativePath string, de *snapshot.DirEntry, e fs.Directory) error
        + Close(ctx context.Context) error
        + WriteFile(ctx context.Context, relativePath string, f fs.File) error
        + FileExists(ctx context.Context, relativePath string, l fs.File) bool
        + CreateSymlink(ctx context.Context, relativePath string, e fs.Symlink) error
        + SymlinkExists(ctx context.Context, relativePath string, l fs.Symlink) bool

    }
    class copier << (S,Aquamarine) >> {
    }
    class restore.streamCopier << (T, #FF7700) >>  {
    }
    class statsInternal << (S,Aquamarine) >> {
        + RestoredTotalFileSize atomic.Int64
        + EnqueuedTotalFileSize atomic.Int64
        + SkippedTotalFileSize atomic.Int64
        + RestoredFileCount atomic.Int32
        + RestoredDirCount atomic.Int32
        + RestoredSymlinkCount atomic.Int32
        + EnqueuedFileCount atomic.Int32
        + EnqueuedDirCount atomic.Int32
        + EnqueuedSymlinkCount atomic.Int32
        + SkippedCount atomic.Int32
        + IgnoredErrorCount atomic.Int32

    }
    class "<font color=blue>func</font>(io.WriteSeeker, io.Reader) (int64, error)" as fontcolorbluefuncfontioWriteSeekerioReaderint64error {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
}
"restore.FilesystemOutput" *-- "restore.ShallowFilesystemOutput"

"restore.Output" <|-- "restore.FilesystemOutput"
"restore.Output" <|-- "restore.TarOutput"
"restore.Output" <|-- "restore.ZipOutput"

namespace retry {
    class retry.IsRetriableFunc << (T, #FF7700) >>  {
    }
}


namespace retrying {
    class retryingStorage << (S,Aquamarine) >> {
        + GetBlob(ctx context.Context, id blob.ID, offset int64, length int64, output blob.OutputBuffer) error
        + GetMetadata(ctx context.Context, id blob.ID) (blob.Metadata, error)
        + PutBlob(ctx context.Context, id blob.ID, data blob.Bytes, opts blob.PutOptions) error
        + DeleteBlob(ctx context.Context, id blob.ID) error

    }
}
"blob.Storage" *-- "retrying.retryingStorage"


namespace s3 {
    class Options << (S,Aquamarine) >> {
        + BucketName string
        + Prefix string
        + Endpoint string
        + DoNotUseTLS bool
        + DoNotVerifyTLS bool
        + RootCA []byte
        + AccessKeyID string
        + SecretAccessKey string
        + SessionToken string
        + Region string
        + PointInTime *time.Time

    }
    class PrefixAndStorageClass << (S,Aquamarine) >> {
        + Prefix blob.ID
        + StorageClass string

    }
    class StorageConfig << (S,Aquamarine) >> {
        + BlobOptions []PrefixAndStorageClass

        + Load(r io.Reader) error
        + Save(w io.Writer) error

    }
    class s3.versionMetadataCallback << (T, #FF7700) >>  {
    }
    class s3PointInTimeStorage << (S,Aquamarine) >> {
        + ListBlobs(ctx context.Context, blobIDPrefix blob.ID, cb <font color=blue>func</font>(blob.Metadata) error) error
        + GetBlob(ctx context.Context, blobID blob.ID, offset int64, length int64, output blob.OutputBuffer) error
        + GetMetadata(ctx context.Context, blobID blob.ID) (blob.Metadata, error)

    }
    class s3Storage << (S,Aquamarine) >> {
        + GetCapacity(ctx context.Context) (blob.Capacity, error)
        + GetBlob(ctx context.Context, b blob.ID, offset int64, length int64, output blob.OutputBuffer) error
        + GetMetadata(ctx context.Context, b blob.ID) (blob.Metadata, error)
        + PutBlob(ctx context.Context, b blob.ID, data blob.Bytes, opts blob.PutOptions) error
        + DeleteBlob(ctx context.Context, b blob.ID) error
        + ListBlobs(ctx context.Context, prefix blob.ID, callback <font color=blue>func</font>(blob.Metadata) error) error
        + ConnectionInfo() blob.ConnectionInfo
        + Close(ctx context.Context) error
        + String() string
        + DisplayName() string
        + FlushCaches(ctx context.Context) error
        + IsVersioned(ctx context.Context) (bool, error)

    }
    class versionMetadata << (S,Aquamarine) >> {
        + IsLatest bool
        + IsDeleteMarker bool
        + Version string

    }
}
"throttling.Limits" *-- "s3.Options"
"s3.s3Storage" *-- "s3.s3PointInTimeStorage"
"s3.Options" *-- "s3.s3Storage"
"blob.Metadata" *-- "s3.versionMetadata"

"blob.Storage" <|-- "s3.s3Storage"
"blob.Volume" <|-- "s3.s3Storage"

namespace server {
    class Options << (S,Aquamarine) >> {
        + ConfigFile string
        + ConnectOptions *repo.ConnectOptions
        + RefreshInterval time.Duration
        + MaxConcurrency int
        + Authenticator auth.Authenticator
        + Authorizer auth.Authorizer
        + PasswordPersist passwordpersist.Strategy
        + AuthCookieSigningKey string
        + LogRequests bool
        + UIUser string
        + UIPreferencesFile string
        + ServerControlUser string
        + DisableCSRFTokenChecks bool
        + UITitlePrefix string

    }
    class Server << (S,Aquamarine) >> {
        + OnShutdown <font color=blue>func</font>(context.Context) error

        + Session(srv grpcapi.KopiaRepository_SessionServer) error
        + RegisterGRPCHandlers(r grpc.ServiceRegistrar) 
        + GRPCRouterHandler(handler http.Handler) http.Handler
        + SetupHTMLUIAPIHandlers(m *mux.Router) 
        + SetupRepositoryAPIHandlers(m *mux.Router) 
        + SetupControlAPIHandlers(m *mux.Router) 
        + Refresh(ctx context.Context) error
        + SetRepository(ctx context.Context, rep repo.Repository) error
        + ServeStaticFiles(m *mux.Router, fs http.FileSystem) 
        + InitRepositoryAsync(ctx context.Context, mode string, initializer InitRepositoryFunc, wait bool) (string, error)

    }
    class apiError << (S,Aquamarine) >> {
    }
    class estimateTaskProgress << (S,Aquamarine) >> {
        + Processing(ctx context.Context, dirname string) 
        + Error(ctx context.Context, dirname string, err error, isIgnored bool) 
        + Stats(ctx context.Context, st *snapshot.Stats, included snapshotfs.SampleBuckets, excluded snapshotfs.SampleBuckets, excludedDirs []string, final bool) 

    }
    class grpcServerState << (S,Aquamarine) >> {
    }
    class requestContext << (S,Aquamarine) >> {
    }
    class server.InitRepositoryFunc << (T, #FF7700) >>  {
    }
    class server.apiRequestFunc << (T, #FF7700) >>  {
    }
    class server.csrfTokenOption << (T, #FF7700) >>  {
    }
    class server.isAuthorizedFunc << (T, #FF7700) >>  {
    }
    interface serverInterface  {
        + Refresh(ctx context.Context) error
        + SetRepository(ctx context.Context, rep repo.Repository) error
        + InitRepositoryAsync(ctx context.Context, mode string, initializer InitRepositoryFunc, wait bool) (string, error)

    }
    class sourceManager << (S,Aquamarine) >> {
        + Status() *serverapi.SourceStatus

    }
    class uitaskProgress << (S,Aquamarine) >> {
        + UploadStarted() 
        + UploadFinished() 
        + CachedFile(path string, size int64) 
        + HashingFile(fname string) 
        + FinishedHashingFile(fname string, numBytes int64) 
        + FinishedFile(fname string, err error) 
        + HashedBytes(numBytes int64) 
        + Error(path string, err error, isIgnored bool) 
        + UploadedBytes(numBytes int64) 
        + StartedDirectory(dirname string) 
        + FinishedDirectory(dirname string) 
        + ExcludedFile(fname string, numBytes int64) 
        + ExcludedDir(dirname string) 
        + EstimatedDataSize(fileCount int, totalBytes int64) 

    }
    class "<font color=blue>func</font>(context.Context) (repo.Repository, error)" as fontcolorbluefuncfontcontextContextrepoRepositoryerror {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "<font color=blue>func</font>(context.Context, requestContext) bool" as fontcolorbluefuncfontcontextContextrequestContextbool {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "<font color=blue>func</font>(context.Context, requestContext) (<font color=blue>interface</font>{}, *apiError)" as fontcolorbluefuncfontcontextContextrequestContextfontcolorblueinterfacefontapiError {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
}
"server.grpcServerState" *-- "server.Server"
"grpcapi.UnimplementedKopiaRepositoryServer" *-- "server.grpcServerState"
"snapshotfs.NullUploadProgress" *-- "server.sourceManager"

"server.serverInterface" <|-- "server.Server"
"snapshotfs.EstimateProgress" <|-- "server.estimateTaskProgress"
"snapshotfs.UploadProgress" <|-- "server.uitaskProgress"

namespace serverapi {
    class AlgorithmInfo << (S,Aquamarine) >> {
        + ID string
        + Deprecated bool

    }
    class CLIInfo << (S,Aquamarine) >> {
        + Executable string

    }
    class CheckRepositoryExistsRequest << (S,Aquamarine) >> {
        + Storage blob.ConnectionInfo

    }
    class ConnectRepositoryRequest << (S,Aquamarine) >> {
        + Storage blob.ConnectionInfo
        + Password string
        + Token string
        + APIServer *repo.APIServerInfo
        + ClientOptions repo.ClientOptions
        + SyncWaitTimeSeconds int

    }
    class CreateRepositoryRequest << (S,Aquamarine) >> {
        + NewRepositoryOptions repo.NewRepositoryOptions

    }
    class CreateSnapshotSourceRequest << (S,Aquamarine) >> {
        + Path string
        + CreateSnapshot bool
        + Policy *policy.Policy

    }
    class CreateSnapshotSourceResponse << (S,Aquamarine) >> {
        + SnapshotStarted bool

    }
    class CurrentUserResponse << (S,Aquamarine) >> {
        + Username string
        + Hostname string

    }
    class DeleteSnapshotsRequest << (S,Aquamarine) >> {
        + SourceInfo snapshot.SourceInfo
        + SnapshotManifestIDs []manifest.ID
        + DeleteSourceAndPolicy bool

    }
    class EditSnapshotsRequest << (S,Aquamarine) >> {
        + Snapshots []manifest.ID
        + NewDescription *string
        + AddPins []string
        + RemovePins []string

    }
    class Empty << (S,Aquamarine) >> {
    }
    class ErrorResponse << (S,Aquamarine) >> {
        + Code APIErrorCode
        + Error string

    }
    class EstimateRequest << (S,Aquamarine) >> {
        + Root string
        + MaxExamplesPerBucket int
        + PolicyOverride *policy.Policy

    }
    class MountSnapshotRequest << (S,Aquamarine) >> {
        + Root string

    }
    class MountedSnapshot << (S,Aquamarine) >> {
        + Path string
        + Root object.ID

    }
    class MountedSnapshots << (S,Aquamarine) >> {
        + Items []*MountedSnapshot

    }
    class MultipleSourceActionResponse << (S,Aquamarine) >> {
        + Sources <font color=blue>map</font>[string]SourceActionResponse

    }
    class PoliciesResponse << (S,Aquamarine) >> {
        + Policies []*PolicyListEntry

    }
    class PolicyListEntry << (S,Aquamarine) >> {
        + ID string
        + Target snapshot.SourceInfo
        + Policy *policy.Policy

    }
    class ResolvePathRequest << (S,Aquamarine) >> {
        + Path string

    }
    class ResolvePathResponse << (S,Aquamarine) >> {
        + SourceInfo snapshot.SourceInfo

    }
    class ResolvePolicyRequest << (S,Aquamarine) >> {
        + Updates *policy.Policy
        + NumUpcomingSnapshotTimes int

    }
    class ResolvePolicyResponse << (S,Aquamarine) >> {
        + Effective *policy.Policy
        + Definition *policy.Definition
        + Defined *policy.Policy
        + UpcomingSnapshotTimes []time.Time

    }
    class RestoreRequest << (S,Aquamarine) >> {
        + Root string
        + Filesystem *restore.FilesystemOutput
        + ZipFile string
        + UncompressedZip bool
        + TarFile string
        + Options restore.Options

    }
    class Snapshot << (S,Aquamarine) >> {
        + ID manifest.ID
        + Description string
        + StartTime fs.UTCTimestamp
        + EndTime fs.UTCTimestamp
        + IncompleteReason string
        + Summary *fs.DirectorySummary
        + RootEntry string
        + RetentionReasons []string
        + Pins []string

    }
    class SnapshotsResponse << (S,Aquamarine) >> {
        + Snapshots []*Snapshot
        + UnfilteredCount int
        + UniqueCount int

    }
    class SourceActionResponse << (S,Aquamarine) >> {
        + Success bool

    }
    class SourceStatus << (S,Aquamarine) >> {
        + Source snapshot.SourceInfo
        + Status string
        + SchedulingPolicy policy.SchedulingPolicy
        + LastSnapshot *snapshot.Manifest
        + NextSnapshotTime *time.Time
        + UploadCounters *snapshotfs.UploadCounters
        + CurrentTask string

    }
    class SourcesResponse << (S,Aquamarine) >> {
        + LocalUsername string
        + LocalHost string
        + MultiUser bool
        + Sources []*SourceStatus

    }
    class StatusResponse << (S,Aquamarine) >> {
        + Connected bool
        + ConfigFile string
        + FormatVersion format.Version
        + Hash string
        + Encryption string
        + ECC string
        + ECCOverheadPercent int
        + Splitter string
        + MaxPackSize int
        + Storage string
        + APIServerURL string
        + SupportsContentCompression bool
        + InitRepoTaskID string

    }
    class SupportedAlgorithmsResponse << (S,Aquamarine) >> {
        + DefaultHashAlgorithm string
        + DefaultEncryptionAlgorithm string
        + DefaultECCAlgorithm string
        + DefaultSplitterAlgorithm string
        + SupportedHashAlgorithms []AlgorithmInfo
        + SupportedEncryptionAlgorithms []AlgorithmInfo
        + SupportedECCAlgorithms []AlgorithmInfo
        + SupportedSplitterAlgorithms []AlgorithmInfo
        + SupportedCompressionAlgorithms []AlgorithmInfo

    }
    class TaskListResponse << (S,Aquamarine) >> {
        + Tasks []uitask.Info

    }
    class TaskLogResponse << (S,Aquamarine) >> {
        + Logs []json.RawMessage

    }
    class UIPreferences << (S,Aquamarine) >> {
        + BytesStringBase2 bool
        + Theme string
        + PageSize int

    }
    class UnmountSnapshotRequest << (S,Aquamarine) >> {
        + Root string

    }
    class serverapi.APIErrorCode << (T, #FF7700) >>  {
    }
}
"serverapi.ConnectRepositoryRequest" *-- "serverapi.CreateRepositoryRequest"
"repo.ClientOptions" *-- "serverapi.StatusResponse"


namespace sftp {
    class Options << (S,Aquamarine) >> {
        + Path string
        + Host string
        + Port int
        + Username string
        + Password string
        + Keyfile string
        + KeyData string
        + KnownHostsFile string
        + KnownHostsData string
        + ExternalSSH bool
        + SSHCommand string
        + SSHArguments string

    }
    class osInterface << (S,Aquamarine) >> {
        + IsExist(err error) bool
        + IsNotExist(err error) bool
        + IsPathSeparator(c byte) bool
        + Mkdir(name string, perm os.FileMode) error

    }
    class sftpConnection << (S,Aquamarine) >> {
        + String() string
        + Close() error

    }
    class sftpImpl << (S,Aquamarine) >> {
        + NewConnection(ctx context.Context) (connection.Connection, error)
        + IsConnectionClosedError(err error) bool
        + GetBlobFromPath(ctx context.Context, dirPath string, fullPath string, offset int64, length int64, output blob.OutputBuffer) error
        + GetMetadataFromPath(ctx context.Context, dirPath string, fullPath string) (blob.Metadata, error)
        + PutBlobInPath(ctx context.Context, dirPath string, fullPath string, data blob.Bytes, opts blob.PutOptions) error
        + DeleteBlobInPath(ctx context.Context, dirPath string, fullPath string) error
        + ReadDir(ctx context.Context, dirname string) ([]os.FileInfo, error)

    }
    class sftpStorage << (S,Aquamarine) >> {
        + GetCapacity(ctx context.Context) (blob.Capacity, error)
        + ConnectionInfo() blob.ConnectionInfo
        + DisplayName() string
        + Close(ctx context.Context) error
        + FlushCaches(ctx context.Context) error

    }
}
"sharded.Options" *-- "sftp.Options"
"throttling.Limits" *-- "sftp.Options"
"sftp.Options" *-- "sftp.sftpImpl"
"sharded.Storage" *-- "sftp.sftpStorage"

"connection.ConnectorImpl" <|-- "sftp.sftpImpl"
"sharded.Impl" <|-- "sftp.sftpImpl"
"blob.Volume" <|-- "sftp.sftpStorage"

namespace sharded {
    interface Impl  {
        + GetBlobFromPath(ctx context.Context, dirPath string, filePath string, offset int64, length int64, output blob.OutputBuffer) error
        + GetMetadataFromPath(ctx context.Context, dirPath string, filePath string) (blob.Metadata, error)
        + PutBlobInPath(ctx context.Context, dirPath string, filePath string, dataSlices blob.Bytes, opts blob.PutOptions) error
        + DeleteBlobInPath(ctx context.Context, dirPath string, filePath string) error
        + ReadDir(ctx context.Context, path string) ([]os.FileInfo, error)

    }
    class Options << (S,Aquamarine) >> {
        + DirectoryShards []int
        + ListParallelism int

    }
    class Parameters << (S,Aquamarine) >> {
        + DefaultShards []int
        + UnshardedLength int
        + Overrides []PrefixAndShards

        + Load(r io.Reader) error
        + Save(w io.Writer) error
        + Clone() *Parameters
        + GetShardDirectoryAndBlob(rootPath string, blobID blob.ID) (string, blob.ID)

    }
    class PrefixAndShards << (S,Aquamarine) >> {
        + Prefix blob.ID
        + Shards []int

    }
    class Storage << (S,Aquamarine) >> {
        + Impl Impl
        + RootPath string

        + GetBlob(ctx context.Context, blobID blob.ID, offset int64, length int64, output blob.OutputBuffer) error
        + ListBlobs(ctx context.Context, prefix blob.ID, callback <font color=blue>func</font>(blob.Metadata) error) error
        + GetMetadata(ctx context.Context, blobID blob.ID) (blob.Metadata, error)
        + PutBlob(ctx context.Context, blobID blob.ID, data blob.Bytes, opts blob.PutOptions) error
        + DeleteBlob(ctx context.Context, blobID blob.ID) error
        + GetShardedPathAndFilePath(ctx context.Context, blobID blob.ID) (string, string, error)

    }
}
"sharded.Options" *-- "sharded.Storage"


namespace snapshot {
    class DirEntry << (S,Aquamarine) >> {
        + Name string
        + Type EntryType
        + Permissions Permissions
        + FileSize int64
        + ModTime fs.UTCTimestamp
        + UserID uint32
        + GroupID uint32
        + ObjectID object.ID
        + DirSummary *fs.DirectorySummary

        + Clone() *DirEntry

    }
    class DirManifest << (S,Aquamarine) >> {
        + StreamType string
        + Entries []*DirEntry
        + Summary *fs.DirectorySummary

    }
    interface HasDirEntry  {
        + DirEntry() *DirEntry

    }
    interface HasDirEntryOrNil  {
        + DirEntryOrNil(ctx context.Context) (*DirEntry, error)

    }
    class Manifest << (S,Aquamarine) >> {
        + ID manifest.ID
        + Source SourceInfo
        + Description string
        + StartTime fs.UTCTimestamp
        + EndTime fs.UTCTimestamp
        + Stats Stats
        + IncompleteReason string
        + RootEntry *DirEntry
        + RetentionReasons []string
        + Tags <font color=blue>map</font>[string]string
        + StorageStats *StorageStats
        + Pins []string

        + UpdatePins(add []string, remove []string) bool
        + RootObjectID() object.ID
        + Clone() *Manifest

    }
    class Permissions << (S,Aquamarine) >> {
        + MarshalJSON() ([]byte, error)
        + UnmarshalJSON(b []byte) error

    }
    class SourceInfo << (S,Aquamarine) >> {
        + Host string
        + UserName string
        + Path string

        + String() string

    }
    class Stats << (S,Aquamarine) >> {
        + TotalFileSize int64
        + ExcludedTotalFileSize int64
        + TotalFileCount int32
        + CachedFiles int32
        + NonCachedFiles int32
        + TotalDirectoryCount int32
        + ExcludedFileCount int32
        + ExcludedDirCount int32
        + IgnoredErrorCount int32
        + ErrorCount int32

        + AddExcluded(md fs.Entry) 

    }
    class StorageStats << (S,Aquamarine) >> {
        + NewData StorageUsageDetails
        + RunningTotal StorageUsageDetails

    }
    class StorageUsageDetails << (S,Aquamarine) >> {
        + ObjectBytes int64
        + OriginalContentBytes int64
        + PackedContentBytes int64
        + FileObjectCount int32
        + DirObjectCount int32
        + ContentCount int32

    }
    class snapshot.EntryType << (T, #FF7700) >>  {
    }
    class snapshot.Permissions << (T, #FF7700) >>  {
    }
}


namespace snapshotfs {
    class CountingUploadProgress << (S,Aquamarine) >> {
        + UploadStarted() 
        + UploadedBytes(numBytes int64) 
        + EstimatedDataSize(numFiles int, numBytes int64) 
        + HashedBytes(numBytes int64) 
        + CachedFile(fname string, numBytes int64) 
        + FinishedHashingFile(fname string, numBytes int64) 
        + FinishedFile(fname string, err error) 
        + ExcludedDir(dirname string) 
        + ExcludedFile(fname string, numBytes int64) 
        + Error(path string, err error, isIgnored bool) 
        + StartedDirectory(dirname string) 
        + Snapshot() UploadCounters
        + UITaskCounters(final bool) <font color=blue>map</font>[string]uitask.CounterValue

    }
    class DirManifestBuilder << (S,Aquamarine) >> {
        + Clone() *DirManifestBuilder
        + AddEntry(de *snapshot.DirEntry) 
        + AddFailedEntry(relPath string, isIgnoredError bool, err error) 
        + Build(dirModTime fs.UTCTimestamp, incompleteReason string) *snapshot.DirManifest

    }
    class DirRewriter << (S,Aquamarine) >> {
        + RewriteSnapshotManifest(ctx context.Context, man *snapshot.Manifest) (bool, error)
        + Close(ctx context.Context) 

    }
    class DirRewriterOptions << (S,Aquamarine) >> {
        + Parallel int
        + RewriteEntry RewriteDirEntryCallback
        + OnDirectoryReadFailure RewriteFailedEntryCallback

    }
    interface EstimateProgress  {
        + Processing(ctx context.Context, dirname string) 
        + Error(ctx context.Context, filename string, err error, isIgnored bool) 
        + Stats(ctx context.Context, s *snapshot.Stats, includedFiles SampleBuckets, excludedFiles SampleBuckets, excludedDirs []string, final bool) 

    }
    class NullUploadProgress << (S,Aquamarine) >> {
        + UploadStarted() 
        + EstimatedDataSize(fileCount int, totalBytes int64) 
        + UploadFinished() 
        + HashedBytes(numBytes int64) 
        + ExcludedFile(fname string, numBytes int64) 
        + ExcludedDir(dirname string) 
        + CachedFile(fname string, numBytes int64) 
        + UploadedBytes(numBytes int64) 
        + HashingFile(fname string) 
        + FinishedHashingFile(fname string, numBytes int64) 
        + FinishedFile(fname string, err error) 
        + StartedDirectory(dirname string) 
        + FinishedDirectory(dirname string) 
        + Error(path string, err error, isIgnored bool) 

    }
    class SampleBucket << (S,Aquamarine) >> {
        + MinSize int64
        + Count int
        + TotalSize int64
        + Examples []string

    }
    class SampleBuckets << (S,Aquamarine) >> {
    }
    class TreeWalker << (S,Aquamarine) >> {
        + ReportError(ctx context.Context, entryPath string, err error) 
        + Err() error
        + TooManyErrors() bool
        + Process(ctx context.Context, e fs.Entry, entryPath string) error
        + Close(ctx context.Context) 

    }
    class TreeWalkerOptions << (S,Aquamarine) >> {
        + EntryCallback EntryCallback
        + Parallelism int
        + MaxErrors int

    }
    class UnreadableDirEntryReplacement << (S,Aquamarine) >> {
        + Info string
        + Error string
        + Entry *snapshot.DirEntry

    }
    class UploadCounters << (S,Aquamarine) >> {
        + TotalCachedBytes int64
        + TotalHashedBytes int64
        + TotalUploadedBytes int64
        + EstimatedBytes int64
        + TotalCachedFiles int32
        + TotalHashedFiles int32
        + TotalExcludedFiles int32
        + TotalExcludedDirs int32
        + FatalErrorCount int32
        + IgnoredErrorCount int32
        + EstimatedFiles int32
        + CurrentDirectory string
        + LastErrorPath string
        + LastError string

    }
    interface UploadProgress  {
        + UploadStarted() 
        + UploadFinished() 
        + CachedFile(path string, size int64) 
        + HashingFile(fname string) 
        + ExcludedFile(fname string, size int64) 
        + ExcludedDir(dirname string) 
        + FinishedHashingFile(fname string, numBytes int64) 
        + FinishedFile(fname string, err error) 
        + HashedBytes(numBytes int64) 
        + Error(path string, err error, isIgnored bool) 
        + UploadedBytes(numBytes int64) 
        + StartedDirectory(dirname string) 
        + FinishedDirectory(dirname string) 
        + EstimatedDataSize(fileCount int, totalBytes int64) 

    }
    class Uploader << (S,Aquamarine) >> {
        + Progress UploadProgress
        + MaxUploadBytes int64
        + ForceHashPercentage float64
        + ParallelUploads int
        + EnableActions bool
        + OverrideDirLogDetail *policy.LogDetail
        + OverrideEntryLogDetail *policy.LogDetail
        + FailFast bool
        + CheckpointInterval time.Duration
        + DisableIgnoreRules bool
        + CheckpointLabels <font color=blue>map</font>[string]string

        + IsCanceled() bool
        + Cancel() 
        + Upload(ctx context.Context, source fs.Entry, policyTree *policy.Tree, sourceInfo snapshot.SourceInfo, previousManifests ...*snapshot.Manifest) (*snapshot.Manifest, error)

    }
    class Verifier << (S,Aquamarine) >> {
        + ShowStats(ctx context.Context) 
        + VerifyFile(ctx context.Context, oid object.ID, entryPath string) error
        + InParallel(ctx context.Context, enqueue <font color=blue>func</font>(*TreeWalker) error) error

    }
    class VerifierOptions << (S,Aquamarine) >> {
        + VerifyFilesPercent float64
        + FileQueueLength int
        + Parallelism int
        + MaxErrors int
        + BlobMap <font color=blue>map</font>[blob.ID]blob.Metadata

    }
    class actionContext << (S,Aquamarine) >> {
        + ActionsEnabled bool
        + SnapshotID string
        + SourcePath string
        + SnapshotPath string
        + WorkDir string

    }
    class checkpointRegistry << (S,Aquamarine) >> {
    }
    class dirReadError << (S,Aquamarine) >> {
    }
    class dirRewriterRequest << (S,Aquamarine) >> {
    }
    class readCloserWithFileInfo << (S,Aquamarine) >> {
        + Entry() (fs.Entry, error)

    }
    class repositoryAllSources << (S,Aquamarine) >> {
        + IsDir() bool
        + Name() string
        + ModTime() time.Time
        + Mode() os.FileMode
        + Size() int64
        + Owner() fs.OwnerInfo
        + Device() fs.DeviceInfo
        + Sys() <font color=blue>interface</font>{}
        + LocalFilesystemPath() string
        + SupportsMultipleIterations() bool
        + Close() 
        + Child(ctx context.Context, name string) (fs.Entry, error)
        + IterateEntries(ctx context.Context, cb <font color=blue>func</font>(context.Context, fs.Entry) error) error

    }
    class repositoryDirectory << (S,Aquamarine) >> {
        + Summary(ctx context.Context) (*fs.DirectorySummary, error)
        + SupportsMultipleIterations() bool
        + Child(ctx context.Context, name string) (fs.Entry, error)
        + IterateEntries(ctx context.Context, cb <font color=blue>func</font>(context.Context, fs.Entry) error) error
        + Close() 

    }
    class repositoryEntry << (S,Aquamarine) >> {
        + IsDir() bool
        + Mode() os.FileMode
        + Name() string
        + Size() int64
        + ModTime() time.Time
        + ObjectID() object.ID
        + Sys() <font color=blue>interface</font>{}
        + Owner() fs.OwnerInfo
        + Device() fs.DeviceInfo
        + DirEntry() *snapshot.DirEntry
        + LocalFilesystemPath() string
        + Close() 

    }
    class repositoryEntryError << (S,Aquamarine) >> {
        + ErrorInfo() error

    }
    class repositoryFile << (S,Aquamarine) >> {
        + Open(ctx context.Context) (fs.Reader, error)

    }
    class repositorySymlink << (S,Aquamarine) >> {
        + Readlink(ctx context.Context) (string, error)

    }
    class scanResults << (S,Aquamarine) >> {
        + Error(ctx context.Context, filename string, err error, isIgnored bool) 
        + Processing(ctx context.Context, pathname string) 
        + Stats(ctx context.Context, s *snapshot.Stats, includedFiles SampleBuckets, excludedFiles SampleBuckets, excludedDirs []string, final bool) 

    }
    class snapshotfs.EntryCallback << (T, #FF7700) >>  {
    }
    class snapshotfs.RewriteDirEntryCallback << (T, #FF7700) >>  {
    }
    class snapshotfs.RewriteFailedEntryCallback << (T, #FF7700) >>  {
    }
    class snapshotfs.SampleBuckets << (T, #FF7700) >>  {
    }
    class snapshotfs.checkpointFunc << (T, #FF7700) >>  {
    }
    class snapshotfs.dirRewriterCacheKey << (T, #FF7700) >>  {
    }
    class sourceDirectories << (S,Aquamarine) >> {
        + IsDir() bool
        + Name() string
        + Mode() os.FileMode
        + ModTime() time.Time
        + Sys() <font color=blue>interface</font>{}
        + Size() int64
        + Owner() fs.OwnerInfo
        + Device() fs.DeviceInfo
        + LocalFilesystemPath() string
        + SupportsMultipleIterations() bool
        + Close() 
        + Child(ctx context.Context, name string) (fs.Entry, error)
        + IterateEntries(ctx context.Context, cb <font color=blue>func</font>(context.Context, fs.Entry) error) error

    }
    class sourceSnapshots << (S,Aquamarine) >> {
        + IsDir() bool
        + Name() string
        + Mode() os.FileMode
        + Size() int64
        + Sys() <font color=blue>interface</font>{}
        + ModTime() time.Time
        + Owner() fs.OwnerInfo
        + Device() fs.DeviceInfo
        + LocalFilesystemPath() string
        + SupportsMultipleIterations() bool
        + Close() 
        + Child(ctx context.Context, name string) (fs.Entry, error)
        + IterateEntries(ctx context.Context, cb <font color=blue>func</font>(context.Context, fs.Entry) error) error

    }
    class uploadWorkItem << (S,Aquamarine) >> {
    }
    class verifyFileWorkItem << (S,Aquamarine) >> {
    }
    class "<font color=blue>func</font>(context.Context, fs.Entry, object.ID, string) error" as fontcolorbluefuncfontcontextContextfsEntryobjectIDstringerror {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "<font color=blue>func</font>(context.Context, string, *snapshot.DirEntry, error) (*snapshot.DirEntry, error)" as fontcolorbluefuncfontcontextContextstringsnapshotDirEntryerrorsnapshotDirEntryerror {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "<font color=blue>func</font>(context.Context, string, *snapshot.DirEntry) (*snapshot.DirEntry, error)" as fontcolorbluefuncfontcontextContextstringsnapshotDirEntrysnapshotDirEntryerror {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "<font color=blue>func</font>() (*snapshot.DirEntry, error)" as fontcolorbluefuncfontsnapshotDirEntryerror {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
}
"snapshotfs.NullUploadProgress" *-- "snapshotfs.CountingUploadProgress"
"__builtin__.error" *-- "snapshotfs.dirReadError"
"object.Reader" *-- "snapshotfs.readCloserWithFileInfo"
"snapshotfs.repositoryEntry" *-- "snapshotfs.repositoryDirectory"
"snapshotfs.repositoryEntry" *-- "snapshotfs.repositoryEntryError"
"snapshotfs.repositoryEntry" *-- "snapshotfs.repositoryFile"
"snapshotfs.repositoryEntry" *-- "snapshotfs.repositorySymlink"

"snapshotfs.UploadProgress" <|-- "snapshotfs.NullUploadProgress"
"fs.Reader" <|-- "snapshotfs.readCloserWithFileInfo"
"fs.Entry" <|-- "snapshotfs.repositoryAllSources"
"fs.DirectoryWithSummary" <|-- "snapshotfs.repositoryDirectory"
"fs.Entry" <|-- "snapshotfs.repositoryEntry"
"object.HasObjectID" <|-- "snapshotfs.repositoryEntry"
"snapshot.HasDirEntry" <|-- "snapshotfs.repositoryEntry"
"fs.ErrorEntry" <|-- "snapshotfs.repositoryEntryError"
"fs.File" <|-- "snapshotfs.repositoryFile"
"fs.Symlink" <|-- "snapshotfs.repositorySymlink"
"snapshotfs.EstimateProgress" <|-- "snapshotfs.scanResults"
"fs.Entry" <|-- "snapshotfs.sourceDirectories"
"fs.Entry" <|-- "snapshotfs.sourceSnapshots"

namespace snapshotgc {
    class Stats << (S,Aquamarine) >> {
        + UnusedBytes int64
        + UnusedCount uint32

    }
}


namespace splitter {
    interface Splitter  {
        + NextSplitPoint(b []byte) int
        + MaxSegmentSize() int
        + Reset() 
        + Close() 

    }
    class buzhash32Splitter << (S,Aquamarine) >> {
        + Close() 
        + Reset() 
        + NextSplitPoint(b []byte) int
        + MaxSegmentSize() int

    }
    class fixedSplitter << (S,Aquamarine) >> {
        + Close() 
        + Reset() 
        + NextSplitPoint(b []byte) int
        + MaxSegmentSize() int

    }
    class rabinKarp64Splitter << (S,Aquamarine) >> {
        + Close() 
        + Reset() 
        + NextSplitPoint(b []byte) int
        + MaxSegmentSize() int

    }
    class recyclableSplitter << (S,Aquamarine) >> {
        + Close() 

    }
    class splitter.Factory << (T, #FF7700) >>  {
    }
}
"splitter.Splitter" *-- "splitter.recyclableSplitter"

"splitter.Splitter" <|-- "splitter.buzhash32Splitter"
"splitter.Splitter" <|-- "splitter.fixedSplitter"
"splitter.Splitter" <|-- "splitter.rabinKarp64Splitter"

namespace stats {
    class CountSum << (S,Aquamarine) >> {
        + Add(size int64) (uint32, int64)
        + Approximate() (uint32, int64)

    }
}


namespace storagemetrics {
    class blobMetrics << (S,Aquamarine) >> {
        + GetBlob(ctx context.Context, id blob.ID, offset int64, length int64, output blob.OutputBuffer) error
        + GetCapacity(ctx context.Context) (blob.Capacity, error)
        + GetMetadata(ctx context.Context, id blob.ID) (blob.Metadata, error)
        + PutBlob(ctx context.Context, id blob.ID, data blob.Bytes, opts blob.PutOptions) error
        + DeleteBlob(ctx context.Context, id blob.ID) error
        + ListBlobs(ctx context.Context, prefix blob.ID, callback <font color=blue>func</font>(blob.Metadata) error) error
        + Close(ctx context.Context) error
        + ConnectionInfo() blob.ConnectionInfo
        + DisplayName() string
        + FlushCaches(ctx context.Context) error

    }
}

"blob.Storage" <|-- "storagemetrics.blobMetrics"
"blob.Volume" <|-- "storagemetrics.blobMetrics"

namespace testdata {
    class testInput << (S,Aquamarine) >> {
        + Name string
        + Input string

    }
}


namespace testlogging {
    class printfWriter << (S,Aquamarine) >> {
        + Write(p []byte) (int, error)
        + Sync() error

    }
    interface testingT  {
        + Helper() 
        + Errorf( string,  ...<font color=blue>interface</font>{}) 
        + Fatalf( string,  ...<font color=blue>interface</font>{}) 
        + Logf( string,  ...<font color=blue>interface</font>{}) 

    }
    class testlogging.Level << (T, #FF7700) >>  {
    }
    class "zapcore.Level" as zapcoreLevel {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
}


namespace testutil {
    class ServerParameters << (S,Aquamarine) >> {
        + BaseURL string
        + SHA256Fingerprint string
        + Password string
        + ServerControlPassword string

        + ProcessOutput(l string) bool

    }
}


namespace throttling {
    class Limits << (S,Aquamarine) >> {
        + ReadsPerSecond float64
        + WritesPerSecond float64
        + ListsPerSecond float64
        + UploadBytesPerSecond float64
        + DownloadBytesPerSecond float64
        + ConcurrentReads int
        + ConcurrentWrites int

    }
    interface SettableThrottler  {
        + Limits() Limits
        + SetLimits(limits Limits) error
        + OnUpdate(handler UpdatedHandler) 

    }
    interface Throttler  {
        + BeforeOperation(ctx context.Context, op string) 
        + AfterOperation(ctx context.Context, op string) 
        + BeforeDownload(ctx context.Context, numBytes int64) 
        + BeforeUpload(ctx context.Context, numBytes int64) 
        + ReturnUnusedDownloadBytes(ctx context.Context, numBytes int64) 

    }
    class semaphore << (S,Aquamarine) >> {
        + Acquire() 
        + Release() 
        + SetLimit(limit int) error

    }
    class throttling.UpdatedHandler << (T, #FF7700) >>  {
    }
    class throttlingStorage << (S,Aquamarine) >> {
        + GetBlob(ctx context.Context, id blob.ID, offset int64, length int64, output blob.OutputBuffer) error
        + GetMetadata(ctx context.Context, id blob.ID) (blob.Metadata, error)
        + ListBlobs(ctx context.Context, blobIDPrefix blob.ID, cb <font color=blue>func</font>(blob.Metadata) error) error
        + PutBlob(ctx context.Context, id blob.ID, data blob.Bytes, opts blob.PutOptions) error
        + DeleteBlob(ctx context.Context, id blob.ID) error

    }
    class tokenBucket << (S,Aquamarine) >> {
        + Take(ctx context.Context, n float64) 
        + TakeDuration(ctx context.Context, n float64) time.Duration
        + Return(ctx context.Context, n float64) 
        + SetLimit(maxTokens float64) error

    }
    class tokenBucketBasedThrottler << (S,Aquamarine) >> {
        + BeforeOperation(ctx context.Context, op string) 
        + AfterOperation(ctx context.Context, op string) 
        + BeforeDownload(ctx context.Context, numBytes int64) 
        + ReturnUnusedDownloadBytes(ctx context.Context, numBytes int64) 
        + BeforeUpload(ctx context.Context, numBytes int64) 
        + Limits() Limits
        + SetLimits(limits Limits) error
        + OnUpdate(handler UpdatedHandler) 

    }
}
"throttling.Throttler" *-- "throttling.SettableThrottler"
"blob.Storage" *-- "throttling.throttlingStorage"

"throttling.SettableThrottler" <|-- "throttling.tokenBucketBasedThrottler"
"throttling.Throttler" <|-- "throttling.tokenBucketBasedThrottler"

namespace timetrack {
    class Estimator << (S,Aquamarine) >> {
        + Estimate(completed float64, total float64) (Timings, bool)
        + Completed(total float64) (time.Duration, float64)

    }
    class Throttle << (S,Aquamarine) >> {
        + ShouldOutput(interval time.Duration) bool
        + Reset() 

    }
    class Timer << (S,Aquamarine) >> {
        + Elapsed() time.Duration

    }
    class Timings << (S,Aquamarine) >> {
        + PercentComplete float64
        + EstimatedEndTime time.Time
        + Remaining time.Duration
        + SpeedPerSecond float64

    }
}


namespace uitask {
    interface Controller  {
        + CurrentTaskID() string
        + OnCancel(cancelFunc context.CancelFunc) 
        + ReportCounters(counters <font color=blue>map</font>[string]CounterValue) 
        + ReportProgressInfo(text string) 

    }
    class CounterValue << (S,Aquamarine) >> {
        + Value int64
        + Units string
        + Level string

    }
    class Info << (S,Aquamarine) >> {
        + TaskID string
        + StartTime time.Time
        + EndTime *time.Time
        + Kind string
        + Description string
        + Status Status
        + ProgressInfo string
        + ErrorMessage string
        + Counters <font color=blue>map</font>[string]CounterValue
        + LogLines []json.RawMessage
        + Error error

    }
    class Manager << (S,Aquamarine) >> {
        + MaxFinishedTasks int
        + MaxLogMessagesPerTask int

        + Run(ctx context.Context, kind string, description string, task TaskFunc) error
        + ListTasks() []Info
        + WaitForTask(ctx context.Context, taskID string, maxWaitTime time.Duration) (Info, bool)
        + TaskSummary() <font color=blue>map</font>[Status]int
        + TaskLog(taskID string) []json.RawMessage
        + GetTask(taskID string) (Info, bool)
        + CancelTask(taskID string) 

    }
    class Status << (S,Aquamarine) >> {
        + IsFinished() bool

    }
    class runningTaskInfo << (S,Aquamarine) >> {
        + CurrentTaskID() string
        + OnCancel(f context.CancelFunc) 
        + ReportProgressInfo(pi string) 
        + ReportCounters(c <font color=blue>map</font>[string]CounterValue) 
        + Write(p []byte) (int, error)
        + Sync() error

    }
    class uitask.LogLevel << (T, #FF7700) >>  {
    }
    class uitask.Status << (T, #FF7700) >>  {
    }
    class uitask.TaskFunc << (T, #FF7700) >>  {
    }
    class "<font color=blue>func</font>(context.Context, Controller) error" as fontcolorbluefuncfontcontextContextControllererror {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
}
"uitask.Info" *-- "uitask.runningTaskInfo"

"uitask.Controller" <|-- "uitask.runningTaskInfo"

namespace user {
    class Profile << (S,Aquamarine) >> {
        + ManifestID manifest.ID
        + Username string
        + PasswordHashVersion int
        + PasswordHash []byte

        + SetPassword(password string) error
        + IsValidPassword(password string) bool

    }
}


namespace virtualfs {
    class staticDirectory << (S,Aquamarine) >> {
        + Child(ctx context.Context, name string) (fs.Entry, error)
        + IterateEntries(ctx context.Context, cb <font color=blue>func</font>(context.Context, fs.Entry) error) error
        + SupportsMultipleIterations() bool

    }
    class streamingDirectory << (S,Aquamarine) >> {
        + Child(ctx context.Context, name string) (fs.Entry, error)
        + IterateEntries(ctx context.Context, callback <font color=blue>func</font>(context.Context, fs.Entry) error) error
        + SupportsMultipleIterations() bool

    }
    class virtualEntry << (S,Aquamarine) >> {
        + Name() string
        + IsDir() bool
        + Mode() os.FileMode
        + ModTime() time.Time
        + Size() int64
        + Sys() <font color=blue>interface</font>{}
        + Owner() fs.OwnerInfo
        + Device() fs.DeviceInfo
        + LocalFilesystemPath() string
        + Close() 

    }
    class virtualFile << (S,Aquamarine) >> {
        + GetReader(ctx context.Context) (io.ReadCloser, error)

    }
}
"virtualfs.virtualEntry" *-- "virtualfs.staticDirectory"
"virtualfs.virtualEntry" *-- "virtualfs.streamingDirectory"
"virtualfs.virtualEntry" *-- "virtualfs.virtualFile"

"fs.Entry" <|-- "virtualfs.virtualEntry"
"fs.StreamingFile" <|-- "virtualfs.virtualFile"

namespace wcmatch {
    class Options << (S,Aquamarine) >> {
        + IgnoreCase bool
        + BaseDir string

    }
    class WildcardMatcher << (S,Aquamarine) >> {
        + Pattern() string
        + Negated() bool
        + Options() Options
        + Match(text string, isDir bool) bool

    }
    class runeScanner << (S,Aquamarine) >> {
    }
    interface seqToken  {
    }
    class seqTokenClass << (S,Aquamarine) >> {
        + String() string

    }
    class seqTokenRune << (S,Aquamarine) >> {
        + Ch rune

        + String() string

    }
    class seqTokenRuneRange << (S,Aquamarine) >> {
        + Start rune

        + String() string

    }
    interface token  {
    }
    class tokenAnyChar << (S,Aquamarine) >> {
        + String() string

    }
    class tokenDirSep << (S,Aquamarine) >> {
        + String() string

    }
    class tokenRune << (S,Aquamarine) >> {
        + Ch rune

        + String() string

    }
    class tokenSeq << (S,Aquamarine) >> {
        + String() string

    }
    class tokenStar << (S,Aquamarine) >> {
        + String() string

    }
    class wcmatch.Option << (T, #FF7700) >>  {
    }
    class wcmatch.matchResult << (T, #FF7700) >>  {
    }
}

"wcmatch.seqToken" <|-- "wcmatch.seqTokenClass"
"wcmatch.seqToken" <|-- "wcmatch.seqTokenRune"
"wcmatch.seqToken" <|-- "wcmatch.seqTokenRuneRange"

namespace webdav {
    class Options << (S,Aquamarine) >> {
        + URL string
        + Username string
        + Password string
        + TrustedServerCertificateFingerprint string
        + AtomicWrites bool

    }
    class davStorage << (S,Aquamarine) >> {
        + GetCapacity(ctx context.Context) (blob.Capacity, error)
        + ConnectionInfo() blob.ConnectionInfo
        + DisplayName() string
        + Close(ctx context.Context) error
        + FlushCaches(ctx context.Context) error

    }
    class davStorageImpl << (S,Aquamarine) >> {
        + GetBlobFromPath(ctx context.Context, dirPath string, path string, offset int64, length int64, output blob.OutputBuffer) error
        + GetMetadataFromPath(ctx context.Context, dirPath string, path string) (blob.Metadata, error)
        + ReadDir(ctx context.Context, dir string) ([]os.FileInfo, error)
        + PutBlobInPath(ctx context.Context, dirPath string, filePath string, data blob.Bytes, opts blob.PutOptions) error
        + DeleteBlobInPath(ctx context.Context, dirPath string, filePath string) error

    }
}
"sharded.Options" *-- "webdav.Options"
"throttling.Limits" *-- "webdav.Options"
"sharded.Storage" *-- "webdav.davStorage"
"webdav.Options" *-- "webdav.davStorageImpl"

"blob.Volume" <|-- "webdav.davStorage"
"sharded.Impl" <|-- "webdav.davStorageImpl"

namespace webdavmount {
    class webdavDir << (S,Aquamarine) >> {
        + Readdir(n int) ([]os.FileInfo, error)
        + Stat() (os.FileInfo, error)
        + Write(b []byte) (int, error)
        + Close() error
        + Read(b []byte) (int, error)
        + Seek( int64,  int) (int64, error)

    }
    class webdavFS << (S,Aquamarine) >> {
        + Mkdir(ctx context.Context, path string, mode os.FileMode) error
        + RemoveAll(ctx context.Context, path string) error
        + Rename(ctx context.Context, oldPath string, newPath string) error
        + OpenFile(ctx context.Context, path string, flags int, mode os.FileMode) (webdav.File, error)
        + Stat(ctx context.Context, path string) (os.FileInfo, error)

    }
    class webdavFile << (S,Aquamarine) >> {
        + Readdir(n int) ([]os.FileInfo, error)
        + Stat() (os.FileInfo, error)
        + Read(b []byte) (int, error)
        + Seek(offset int64, whence int) (int64, error)
        + Write(b []byte) (int, error)
        + Close() error

    }
    class webdavFileInfo << (S,Aquamarine) >> {
    }
}
"fs.Entry" *-- "webdavmount.webdavFileInfo"

"filesystem.osReadFile" <|-- "webdavmount.webdavDir"
"filesystem.osReadFile" <|-- "webdavmount.webdavFile"

namespace workshare {
    class _workshare << (S,Aquamarine) >> {
        + ActiveWorkers() int
        + Close() 
        + Wait() []T
        + Close() 
        + RunAsync(w *, process , request T) 
        + CanShareWork(w *) bool

    }
    class AsyncGroup << (S,Aquamarine) >> {
    }
    class Pool << (S,Aquamarine) >> {
    }
    class workItem << (S,Aquamarine) >> {
    }
    class workshare.ProcessFunc << (T, #FF7700) >>  {
    }
}


namespace zaplogutil {
    class StdConsoleEncoderConfig << (S,Aquamarine) >> {
        + TimeLayout string
        + LocalTime bool
        + EmitLoggerName bool
        + EmitLogLevel bool
        + DoNotEmitInfoLevel bool
        + ColoredLogLevel bool

    }
    class stdConsoleEncoder << (S,Aquamarine) >> {
        + Clone() zapcore.Encoder
        + EncodeEntry(ent zapcore.Entry, fields []zapcore.Field) (*buffer.Buffer, error)

    }
    class theClock << (S,Aquamarine) >> {
        + Now() time.Time
        + NewTicker(d time.Duration) *time.Ticker

    }
}
"zapcore.Encoder" *-- "zaplogutil.stdConsoleEncoder"
"zaplogutil.StdConsoleEncoderConfig" *-- "zaplogutil.stdConsoleEncoder"


"__builtin__.fontcolorbluemapfontblobIDbyte" #.. "blobtesting.DataMap"
"__builtin__.<font color=blue>map</font>[string]string" #.. "acl.TargetRule"
"__builtin__.[]byte" #.. "cacheprot.authenticatedEncryptionProtectionKey"
"__builtin__.[]byte" #.. "snapshotfs.dirRewriterCacheKey"
"__builtin__.bool" #.. "policy.OptionalBool"
"__builtin__.float64" #.. "content.DurationSeconds"
"__builtin__.int" #.. "acl.AccessLevel"
"__builtin__.int" #.. "fault.Method"
"__builtin__.int" #.. "format.Version"
"__builtin__.int" #.. "policy.LogDetail"
"__builtin__.int" #.. "policy.OptionalInt"
"__builtin__.int" #.. "server.csrfTokenOption"
"__builtin__.int" #.. "snapshot.Permissions"
"__builtin__.int" #.. "uitask.LogLevel"
"__builtin__.int" #.. "wcmatch.matchResult"
"__builtin__.int32" #.. "grpcapi.ErrorResponse_Code"
"__builtin__.int64" #.. "fs.UTCTimestamp"
"__builtin__.int64" #.. "policy.OptionalInt64"
"__builtin__.string" #.. "blob.ID"
"__builtin__.string" #.. "blob.RetentionMode"
"__builtin__.string" #.. "compression.Name"
"__builtin__.string" #.. "content.SessionID"
"__builtin__.string" #.. "feature.Behavior"
"__builtin__.string" #.. "feature.Feature"
"__builtin__.string" #.. "index.IDPrefix"
"__builtin__.string" #.. "localfs.PlaceholderFilePath"
"__builtin__.string" #.. "logging.contextKey"
"__builtin__.string" #.. "maintenance.Mode"
"__builtin__.string" #.. "maintenance.TaskType"
"__builtin__.string" #.. "manifest.ID"
"__builtin__.string" #.. "releasable.ItemKind"
"__builtin__.string" #.. "serverapi.APIErrorCode"
"__builtin__.string" #.. "snapshot.EntryType"
"__builtin__.string" #.. "uitask.Status"
"__builtin__.uint32" #.. "compression.HeaderID"
"acl.<font color=blue>func</font>(string) error" #.. "acl.valueValidatorFunc"
"auth.[]Authenticator" #.. "auth.combinedAuthenticator"
"auth.aclAccessLevel" #.. "auth.AccessLevel"
"beforeop.fontcolorbluefuncfontcontextContexterror" #.. "beforeop.callback"
"beforeop.fontcolorbluefuncfontcontextContextblobIDerror" #.. "beforeop.onGetBlobCallback"
"beforeop.fontcolorbluefuncfontcontextContextblobIDblobPutOptionserror" #.. "beforeop.onPutBlobCallback"
"blobtesting.fontcolorbluemapfontblobIDentry" #.. "blobtesting.versionedEntries"
"cachefs.fontcolorbluefuncfontcontextContextfsEntryerror" #.. "cachefs.Loader"
"cachefs.fontcolorbluefuncfontfsEntryfsEntry" #.. "cachefs.EntryWrapper"
"content.<font color=blue>func</font>() error" #.. "content.cancelIterateFunc"
"content.<font color=blue>func</font>(Info) error" #.. "content.IterateCallback"
"content.<font color=blue>func</font>(PackInfo) error" #.. "content.IteratePacksCallback"
"content.indexID" #.. "content.ID"
"content.indexIDPrefix" #.. "content.IDPrefix"
"content.indexIDRange" #.. "content.IDRange"
"content.indexInfo" #.. "content.Info"
"content.indexInfoStruct" #.. "content.InfoStruct"
"ecc.fontcolorbluefuncfontOptionsencryptionEncryptorerror" #.. "ecc.CreateECCFunc"
"encryption.<font color=blue>func</font>(Parameters) (Encryptor, error)" #.. "encryption.EncryptorFactory"
"epoch.fontcolorbluefuncfontcontextContextblobIDblobIDerror" #.. "epoch.CompactionFunc"
"hashing.<font color=blue>func</font>(Parameters) (HashFunc, error)" #.. "hashing.HashFuncFactory"
"hashing.fontcolorbluefuncfontbytegatherBytesbyte" #.. "hashing.HashFunc"
"ignorefs.<font color=blue>func</font>(*ignoreContext) " #.. "ignorefs.Option"
"ignorefs.fontcolorbluefuncfontcontextContextstringfsEntrypolicyTree" #.. "ignorefs.IgnoreCallback"
"index.<font color=blue>map</font>[ID]{packageName}Info" #.. "index.Builder"
"index.[]*nextInfo" #.. "index.nextInfoHeap"
"index.[]Index" #.. "index.Merged"
"logging.zapSugaredLogger" #.. "logging.Logger"
"logging.<font color=blue>func</font>(string) Logger" #.. "logging.LoggerFactory"
"loggingfs.<font color=blue>func</font>(*loggingOptions) " #.. "loggingfs.Option"
"parallelwork.<font color=blue>func</font>() error" #.. "parallelwork.CallbackFunc"
"passwordpersist.[]Strategy" #.. "passwordpersist.Multiple"
"policy.<font color=blue>map</font>[string]*Policy" #.. "policy.SubdirectoryPolicyMap"
"repo.fontcolorbluefuncfontcontextContexterror" #.. "repo.closeFunc"
"repo.fontcolorbluefuncfontcontextContextRepositoryWritererror" #.. "repo.RepositoryWriterCallback"
"restore.fontcolorbluefuncfontioWriteSeekerioReaderint64error" #.. "restore.streamCopier"
"retry.<font color=blue>func</font>(error) bool" #.. "retry.IsRetriableFunc"
"s3.<font color=blue>func</font>(versionMetadata) error" #.. "s3.versionMetadataCallback"
"server.fontcolorbluefuncfontcontextContextrepoRepositoryerror" #.. "server.InitRepositoryFunc"
"server.fontcolorbluefuncfontcontextContextrequestContextfontcolorblueinterfacefontapiError" #.. "server.apiRequestFunc"
"server.fontcolorbluefuncfontcontextContextrequestContextbool" #.. "server.isAuthorizedFunc"
"snapshotfs.fontcolorbluefuncfontsnapshotDirEntryerror" #.. "snapshotfs.checkpointFunc"
"snapshotfs.fontcolorbluefuncfontcontextContextfsEntryobjectIDstringerror" #.. "snapshotfs.EntryCallback"
"snapshotfs.fontcolorbluefuncfontcontextContextstringsnapshotDirEntrysnapshotDirEntryerror" #.. "snapshotfs.RewriteDirEntryCallback"
"snapshotfs.fontcolorbluefuncfontcontextContextstringsnapshotDirEntryerrorsnapshotDirEntryerror" #.. "snapshotfs.RewriteFailedEntryCallback"
"snapshotfs.[]*SampleBucket" #.. "snapshotfs.SampleBuckets"
"splitter.<font color=blue>func</font>() Splitter" #.. "splitter.Factory"
"testlogging.zapcoreLevel" #.. "testlogging.Level"
"throttling.<font color=blue>func</font>(Limits) error" #.. "throttling.UpdatedHandler"
"uitask.fontcolorbluefuncfontcontextContextControllererror" #.. "uitask.TaskFunc"
"wcmatch.<font color=blue>func</font>(*Options) " #.. "wcmatch.Option"
"workshare.<font color=blue>func</font>(*, T) " #.. "workshare.ProcessFunc"
hide fields
@enduml
